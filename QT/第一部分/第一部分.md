# QT初步简介
## 内容重述
> `QT`，hello word!,初步`建立`UI，`代码生成`UI，代码和手动UI`优缺点`对比，`默认生成文件对比`，Object Trees`自动释放`子类new空间，`信号和槽`

## 启动QT

![启动QT桌面的应用](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtic2O0MkovYJ6NZ3JsfkuGFTHsLKFIzTeuosptkh8ic67iciazAB2J10IBC5LCn05O19NnJlDfjfbhFw/0?wx_fmt=png "启动QT桌面的应用")

### 基于对话框！Dialog

> 创建新项目，基于如下相关设置，`QDialog`基于对话框的QT
>
> ![选择建立的系统](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtic2O0MkovYJ6NZ3JsfkuGFIKcRTOEV1LiaM2r0czibdiaziaDpxSR3oIOML6OHURTcR0bRAWsBL1wxZQ/0?wx_fmt=png "选择建立的系统使用qmake")

![选择class类型以及class名字](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtic2O0MkovYJ6NZ3JsfkuGFCfv06x86Yoviavkiak6B2sN0Ku21XPU6SFeGQnqOzhNOuTVCxgxTKxpg/0?wx_fmt=png "选择class类型以及class名字")

![选择编译组件](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtic2O0MkovYJ6NZ3JsfkuGFN9wUtwt1zpASrxn1xZOdcTMWY6HsjefSgVWcIpic8KheIlsiaQNbg8JA/0?wx_fmt=png "选择编译组件")

![最后的summary](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtic2O0MkovYJ6NZ3JsfkuGFiaDzEf5CVSHz2ypwNMgAq5QSJlSeBCX7ibPAoRjVeCktPlcx68Um3nsw/0?wx_fmt=png "最后的summary")

### UI编辑区

![UI编辑区](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtic2O0MkovYJ6NZ3JsfkuGF5oDibYkAK5e8yt9GlGELzUzA4K5WYibnyne0ibFaHFf7icTCynrI8WKGlg/0?wx_fmt=png "UI编辑区")

### 修改logo

> 在编辑的`pro`文件下，最后添加`RC_ICONS = myico.ico`
>
> 此ico文件需要`提前`在下载并放到文件代码所在位置

![添加窗口logo](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtic2O0MkovYJ6NZ3JsfkuGF9sxMr2mqdGdiaLvajMtk3dzeTMxc3oa6XWSMfhmwibaZRcsPO9lcGo3g/0?wx_fmt=png "添加窗口logo")

### 运行

> 点击左下角的运行，可选择`调试`和`发布`两种，当要发布当前文件时选择`release`

![hello word执行窗口](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtic2O0MkovYJ6NZ3JsfkuGF8DAb3fejQicx7WcJsCf6rMkgqEBc6AC0mnicSH1WQBbJmKGtlj6VAiaVQ/0?wx_fmt=png "hello word执行窗口")

### QT软件的发布

> 在QT文件夹下使用`QT cmd`窗口输入,使用`windeployqt`将QT运行所需要的动态库存入到myfirstQTAPP当中（注意myfirstQTAPP需要提前将QT release所生成的exe文件存入到此文件夹中）。
```sh
windeployqt E:\C++study\QT\QT_exercise\QT01\myfirstQTAPP
```

![生成后发布的文件](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtic2O0MkovYJ6NZ3JsfkuGFlhA4DnQS3r76YBs3BRQbZEsIibs31X4Czw0PC409qDkleuIFG6A1n6A/0?wx_fmt=png "生成后发布的文件")

### Qwidget

> 创建项目`Base class `选择`Qwidget`创建的界面对所有的界面相关组件都是支持的

#### .pro文件详解

```
# 在此项目中加入core gui核心（控制台不需要)
# QT是以模块的形式组织类库，根据项目需求不同添加不同类库的支持
QT       += core gui

# 当QT版本大于4，在当前项目中添加widgets
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

CONFIG += c++17

# You can make your code fail to compile if it uses deprecated APIs.
# In order to do so, uncomment the following line.
#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000    # disables all the APIs deprecated before Qt 6.0.0

# 都为自动生成的
# 源代码
SOURCES += \
    main.cpp \
    widgets.cpp
# 头文件
HEADERS += \
    widgets.h
# ui文件
FORMS += \
    widgets.ui

# Default rules for deployment.默认部署规则
qnx: target.path = /tmp/$${TARGET}/bin
else: unix:!android: target.path = /opt/$${TARGET}/bin
!isEmpty(target.path): INSTALLS += target
```
****
> 槽类似`信号`，当点击之后对相关函数进行响应。

![槽](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtic2O0MkovYJ6NZ3JsfkuGFHaHZr1RLWMYOMUEluvIV81h1ImicrpXcLVLh3MviarCnX1kswv30xv1A/0?wx_fmt=png "槽")

> `Signals and Slots Editor`信号与槽编辑，
* 发送者即点击的对象，如图点击pushButton_2上面close，
* 第二个信号为`clicked()`即当点击发送者的时候,
* 接受者为  发送者执行信号`clicked()`然后接受者`执行`槽
* close()接受者widgets(窗口)即`关闭窗口`,
![信号与槽操作](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtic2O0MkovYJ6NZ3JsfkuGFbicJEs1RPFfE0M27m036v8lHdD3jogquSNWjYNxrXUibQz9tTUxqCI9w/0?wx_fmt=png "信号与槽操作")

### main.cpp

```cpp
#include "widgets.h"

#include <QApplication>  //qt的标准应用程序，QT必须有得

int main(int argc, char *argv[])
{
    //a为当前QT的应用程序的对象
    QApplication a(argc, argv);
    //widgets创建w对象
    widgets w;
    //w调用show方法，显示窗体
    w.show();
    //a为qt的应用程序，返回让qt执行起来
    return a.exec();
}
```
### widgets.h

```cpp
#ifndef WIDGETS_H
#define WIDGETS_H

#include <QWidget>

QT_BEGIN_NAMESPACE
//命名空间Ui里面的widgets类
namespace Ui { class widgets; }
QT_END_NAMESPACE
//此widgets与上面命名空间的ui里的widgets不同，在不同的命名空间
class widgets : public QWidget //来自Qwidget基类
{
    //宏，使用QT的信号与槽都要使用到此宏
    Q_OBJECT

public:
    //构造函数和析构函数
    widgets(QWidget *parent = nullptr);
    ~widgets();

private:
    //私有成员ui命名空间里面的widgets
    Ui::widgets *ui;
};
#endif // WIDGETS_H
```
### widgets.cpp
```cpp
#include "widgets.h"
#include "ui_widgets.h"

widgets::widgets(QWidget *parent)
    : QWidget(parent), ui(new Ui::widgets) //开辟类内存空间
{
    //调用setupUi，
    ui->setupUi(this); //实现窗口的各种空间属性，信号与槽关联等
}

widgets::~widgets()
{
    // 析构函数释放new的空间
    delete ui;
}
```

## 使用代码实现在widgets上的功能
> `QMainWindow带菜单栏`的窗口
> 使用代码实现不创建UI相关文件

![image-20230316205038542](E:\学习笔记\Markdown\C-notebook\QT\第一部分\assets\image-20230316205038542.png)

###  可视化和代码编写对比：

* 可视化`不`用编写代码，极大的省去界面布局调节时间成本
* 但有些组件没法完全通过ui进行可视化添加需要设计`纯代码`
* 纯代码确实效率会低，繁琐，但`可补充ui`无法实现的功能

### 对象数Object Trees

> QObjects organize themselves in object trees. When you create a `QObject` with another object as `parent`, it's added to the parent's children() list, and is deleted when the parent is. It turns out that this approach fits the needs of GUI objects very well. For example, a QShortcut (keyboard shortcut) is a child of the relevant window, so when the user closes that window, the shortcut is deleted too.
QQuickItem, the basic visual element of the Qt Quick module, inherits from QObject, but has a concept of the visual parent which differs from that of the QObject parent. An item's visual parent may not necessarily be the same as its object parent. See Concepts - Visual Parent in Qt Quick for more details.
QWidget, the fundamental class of the Qt Widgets module, extends the parent-child relationship. A child normally also becomes a child widget, i.e. it is displayed in its parent's coordinate system and is graphically clipped by its parent's boundaries. For example, `when` the application deletes a message box after it has been closed, the message box's buttons and label are `also` deleted, just as we'd want, because the buttons and label are children of the message box.
You can also delete child objects yourself, and they will remove themselves from their parents. For example, when the user removes a toolbar it may lead to the application deleting one of its QToolBar objects, in which case the tool bar's QMainWindow parent would detect the change and reconfigure its screen space accordingly.
The debugging functions QObject::dumpObjectTree() and QObject::dumpObjectInfo() are often useful when an application looks or acts strangely.

### QDebug
> In the common case, it is useful to call the qDebug() function to obtain a default QDebug object to use for `writing debugging information`.
```cpp
#include <QDebug> //引用QDebug头文件
qDebug() << "Date:" << QDate::currentDate();
```
### 在NO_UI新建一个QMyClass类

> 验证Object Trees关闭是否可以`自动释放`new的空间，而`无需`再析构函数手动delete申请的空间

### 代码验证
#### widget.h
```cpp
#ifndef WIDGET_H
#define WIDGET_H

#include <QWidget>

class Widget : public QWidget
{
    Q_OBJECT

public:
    Widget(QWidget *parent = nullptr);
    ~Widget();
};
#endif // WIDGET_H
```
#### widget.cpp
```cpp
#include "widget.h"
#include <QLabel>
#include <QPushButton>
#include "qmyclass.h" //引用刚才自己创建的类
//对象树//窗口部件的销毁也会相应销毁子部件label等内容申请的空间
//所以只需申请new而无需delete
Widget::Widget(QWidget *parent)
    : QWidget(parent)
{
    //让其窗口隶属于父类1,2,3
    //请求Qlabel空间
    QLabel *label = new QLabel(this); //3,直接带参数，直接隶属于其父类
    //设立text文件
    label->setText("I Love You,XinXin");
    //设置位置
    label->move(150,100);

    //c创建按钮,但并未有操作功能
    QPushButton *button = new QPushButton(this);
    button->setText("Close");
    button->move(150,180);

    //当窗口被关闭后，QMyClass的析构函数也被自动调用
    //只需写new，无需再手动写含delete的内容
    QMyClass *myclass = new QMyClass(this);


    //1,此形式呈现会呈现在独立的窗口
    //label->show();

    //2,让label隶属于其父类
    //label->setParent(this);

    //指定窗体的大小
    resize(400,300);
    //锁定大小,不可改变
    //setFixedSize(400,300);

    setWindowTitle("My First No UI");

}

Widget::~Widget()
{
    //

}
```
#### qmyclass.h
```cpp
#ifndef QMYCLASS_H
#define QMYCLASS_H

#include <QWidget>

class QMyClass : public QWidget
{
    Q_OBJECT
public:
    explicit QMyClass(QWidget *parent = nullptr);
    ~QMyClass(); //作为判断析构函数是否被调用到
signals:

};

#endif // QMYCLASS_H
```
#### qmyclass.cpp
```cpp
#include "qmyclass.h"
#include <QDebug>  //输出内容头文件
QMyClass::QMyClass(QWidget *parent)
    : QWidget{parent}
{

}
QMyClass::~QMyClass()
{
    //QT打印内容,qDebug输出内容
    qDebug() << "delete myclass"; //当手动关系窗口，析构函数被调用
}
```
#### main.cpp和NO_UI.pro不变

## 槽与信号





