# 面向对象三大特征
>* `封装`是指将数据和行为组合成一个整体，对外部`隐藏`内部的`实现细节，`只提供必要的`接口`。封装可以`保护`数据的`安全性`，`降低`代码的`复杂度`，`提高`代码的`可维护性`。C++通过`private,protected，public`关键字来`控制`成员变量和成员函数的`访问权限`
>* `继承`是指`子类可以继承父类`的属性和方法，并且可以`添加或修`改自己特有的属性和方法。`继承`可以提高`代码的复用性`；`提高`代码的`扩展性`；同时也是`多态的前提`
>* `多态`是指`不同类型的对象`对`同一消息`可以做出`不同的响应`。多态可以分为`编译时`和`运行时`多态。`编译`时多态是指通过`重载实现`的多态，即在同一类中定义了相同名称但不同参数的方法，根据调用时传递的参数不同而执行不同方法，`运行时多态`是指通过`重写实现的多态`，即在`子类中重新定义父类中已有的方法`，根据调用时`使用的对象不同`而`执行不同的方法`。多态可以实现`接口的同一`，增加`程序`的`灵活性`和可`扩展性`。

# C++类型转换

* `static_cast`：明确指出`类型转换`，没有动态类型检查，`上行转换`(派生类到基类)`安全`，`下行转换`(基类到派生类)`不安全`。
* `dynamic_cast`: 用于`有条件`的转换，`动态类型`检查，运行时检查类型安全(转换失败返回NULL)，只能用于`多态类型`的`指针或引用`
* `const_cast`：用于改变运算对象的`底层const属性`，`不能改`变其`顶层const属性`
* `reinterpret_cast`: 用于`无关类型之间`的转换，如`整型和指针，不同类型的指针`等。

# STL常见的容器

## 顺序容器

* `vector` : 可变`大小数组`，支持`快速随机访问`。在尾部之外的位置`增删元素可能很慢`
* `deque` ：双端队列。支持`快速随机访问`。在`尾部之外`的位置增删元素`可能很慢`
* `list` : `双向链表`。只支持`双向顺序访问`，在任何位置增删元素都能在`常数时间`完成。不支持随机存取
* `forward_list` ：`单向链表`，只支持单向顺序访问，在链表的任何位置增删元素都能在常数时间内完成，由于没有了size操作以及简化了增删元素的链节点操作，速度相比双向链表更快，不支持随机存取
* `strin`g :字符串。与vector相似，但专门用于保存字符。随机访问块，子尾部增删元素块
* `array`：`定长数组`。支持`快速随机访问`，不能添加和删除元素

## 关联容器

* `map` ： 关联容器。保存键值对 
* `set` ：关键字取值，即只`保存关键字`的容器,--`底层红黑树`
* `multimap` : 关键字`可`重复的map
* `multiset` ：关键字`可`重复出现的set
* `unordered_map` : 用`hash函数`组织的`map`
* `unordered_set` : 用`hash函数`组织的`set`
* `unordered_multimap` : 用`hash函数`组织的`map`，关键字`可重`复出现
* `unordered_multiset` : 用`hash函数`组织的`se`t，关键字`可重`复出现

# 简述vector实现原理

> vector是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。
>
> 由于具有连续的存储空间，所以在插入和删除操作方面，效率较低。当vectoor的大小和容器相等(size == capacity)，如果再向其添加元素，那么vector就需要扩容，vector容器扩容的过程需要经历
>
> * 完全摒弃现有的内存空间，重新申请更大的内存空间
> * 将旧内存空间中的数据，按原有顺序移动到新的内存空间
> * 最后将旧的内存空间释放，vector扩容非常耗时，为了降低再次分配内存空间时的成本，每次扩容时vector都会申请比用户需求量更多的内存空间(这也就是vector容量的由来，即capacity>=size)，以便后期使用
>
> 不同的编译器在扩容时所采用的扩容因子可能不同，比如MSVC的扩容因子为1.5，即每次扩容时容量变为原来的1.5倍。

# unordered_map实现原理

> unordered_map 是一种无序的关联容器，它存储了键值对的集合，其中每个键都是唯一的
>
> unordered_map 的实现原理是基于hash表，通过把关键码映射到hash表中的一个位置来访问记录
>
> unordered_map 中的元素没有按照他们的键值或映射值的任何顺序排序，而是根据他们的散列值组织成桶允许它们的键值直接快速访问单个元素(通常平常平局时间复杂度)
>
> 当两个元素具有相同的散列值时，会发生hash冲突，为了解决这个问题，unordered_map采用了链地址法，即每个桶中存储一个链表，链表中存放所有散列值相同的元素。

# 简述map实现原理，各操作的时间复杂度

>* map是一个模板类，它的模版参数是键值对的类型和比较函数。比较函数用来定义键值对之间的大小关系，从而确认键值对在红黑树中的位置
>* map的底层数据结构也是红黑树，它与set的红黑树相同，只是每个节点存储的不是单个元素，而是一个pair对象，包含一个key和一个value
>* map的插入操作是先在红黑树中找到合适的位置，然后创建一个新节点，并将其颜色设为红色。如果新节点的父节点也是红色，那么就需要进行旋转和变色操作来回复平衡
>* map的删除操作是先在红黑树中找到要删除的节点，然后其后继或前屈替换它，并释放原来的节点。如果被删除或替换的节点是黑色，那么就需要进行旋转和变色操作来回复平衡。
>* map的查找操作是沿着二叉搜索树的路径向下查找，直到直到目标键值对或者未空为止
>
>由于红黑树保证了高度平衡，因此各操作的 时间复杂度均为O(log n)



## 简述map和unordered_map区别

> map基于红黑树实现，该结构具有中排序功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，红黑树的效率决定了map的效率，其增删改查时间复杂度O(log n)
>
> 而unordered_map内部实现了一个hash表，因此其元素的排列顺序是杂乱的，无序的。且增删改查时间复杂度为O(1)