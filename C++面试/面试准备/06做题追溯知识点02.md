# swap函数

> [交换函数](https://zh.cppreference.com/w/cpp/algorithm/swap)

```cpp
// 支持多种类型
swap(a,b); // 交换a和b的值，
```

# switch连续

```cpp
#include <iostream>
using namespace std;

int main() {
    
    int month;
    cin >> month;
    // write your code here......
    if(month < 1 || month > 12)
        cout << "不合法" <<endl;
    else{
        switch (month) {
            case 3 ... 5:   //可以使用连续的数
                cout<<"春季"<<endl;
                break;
            case 6 ... 8:
                cout<<"夏季"<<endl; 
                break;
            case 9 ... 11:
                cout<<"秋季"<<endl;
                break;
            default:
                cout<<"冬季"<<endl;
        }
    }
    return 0;
}
```



# 输出

> `作用永久`，`贯穿`整个`程序`，直到`格式状态改变`设置为其他函数

```cpp
// 设置输出格式
dec //置基数位10，相当于%d
hex // 置基数位16，相当于%x
oct // 置基数位8，相当于%o

cout << 12 << endl;//默认十进制
cout << dec << 12 << endl;//十进制
cout << hex << 12 << endl;//十六进制
cout << oct << 12 << endl;//八进制

// 设置保留一个小数 
cout << fixed << setprecision(1);
```

# 运行状态

> `就绪`： 除了`CPU资源`，获得`了所有必要`资源，只要获取CPU，便可立即执行，进行此时状态为`就绪 `状态，当一个系统中处于就绪状态的进程可能有多个，排成一个队列 -- `就绪队列`
>
> `阻塞`：正在执行的进程，由于等待某个事件(`缺外部资源`)发生 而无法执行，便放弃CPU而处于阻塞状态。

![运行状态转换](https://mmbiz.qpic.cn/mmbiz_jpg/ORog4TEnkbvE3kkddHclPTRwJK2F4mCm2Vy5LTdO0RtPbxwL6B5mhLL0Kib8cQyUzt6PkgKQAF6FYo9ddsahXog/640?wx_fmt=jpeg "运行状态")

# 动态分区分配算法

> 在动态分区分配方式中，当很多个空闲分区 都能满足需求时，如何选择

* `首次适应`算法First Fit

> 每次都从`低`地址开始查找，找到`第一个能满足` 大小的空闲分区

* `最佳适应`算法 Best Fit

> 为了保证`大进程`到来时能有连续得到大片空间。空闲分区按容量递增次序链接，每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小`满足要求的`第一个空闲分区。

* `最坏(大)`适应算法

> 每次分配优先`使用最大的`连续空闲区，这样分配后剩余空闲区不会太小，更方便使用，空闲分区按`容量递减`次序链接，每次分配内存时`顺序查找`空闲分区链或空闲分区表，找到大小能满足要求 的第一个空闲分区

* 临近适应算法

> 空闲分区以地址`递增`的顺序排列(可排成一个`循环链表`),每次分配内存时从`上次查找结束`的位置开始查找`空闲分区链`(或空闲分区表)，找到大小能满`足要求`的`第一个`空闲分区。



# 网络层次

>
>
>![网络层次](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbvE3kkddHclPTRwJK2F4mCmXJMsfcqwIQgVoqWwHxSv643EelRJT4w51ruqtYxrV5kjPmrUZOfY8Q/640?wx_fmt=png)

# this指针

> `this指针`是类的指针，指向`对象`的`首地址`.
>
> this实际上是成员函数的一个`形参`，在调用成员函数时将对象的地址作为实参传递给this，this指针只能在成员函数中使用。在静态成员函数中不能用this
>
> `非静态成员`都包含一个`特殊的指针`，指向`调用`该函数的对象，这个`指针`成为`this指针`

## 特点

* 只能在成员函数中会用，`全局`和`静态函数`，`友元函数`没有`this指针`
* this在成员函数的`开始前构造`，在成员函数的`结束后清除`
* this指针不能被修改和赋值(它存放的是某一类对象地址)
* `this指针`是一个隐含指针，是类成员函数的第一个默认参数，在函数体内可隐含使用它来访问本类的数据成员和成员函数，它并由编译器自动维护传递
* `this指针`是`局部变量`
* this指针只有在`对象调用成员函`数时才被`初始化重新定向`，进入后`不能再被修改`
* `this`并不是对象的一部分，`不影响sizeof结果。`

# 多进程fork与vfork

> vfork()函数和fork函数一样都是在已有的进程中创建进程。每个进程拥有0~3G的虚拟内存空间(包含堆，栈区，静态库，文件描述符表等)
>
> 区别：
>
> * 执行顺序：
>
> * fork() : 父子进程的执行次序不确定
> * vfork() : 保证`子进程`先运行，在它调用`exec/exit`之后，`父进程`才执行
> * 是否拷贝父进程的地址空间
> * `fork() `: `子`进程`拷贝`父进程的`地址空间`，`子`进程是父进程的一个`复制品`
> * `vfork()`：子进程`共享`父进程的地址空间

```cpp
pid_t pid = fork();
//返回-1，进程创建失败
// 根据pid ==0 ，子进程
// pid >0 父进程
```

> 监控子进程wait函数,返回终止的进程ID



## 僵尸进程

> 当子进程先于父进程终止，而父进程又没有调用wait函数等待子进程结束，子进程进入僵尸状态，此时子进程调用始终占用着资源，同时也较少了系统可以创建的最大进程数，且会一直保持下去除非系统重启。





## 进程函数





## 进程类Linux指令

```sh


```



# const区分重载

```cpp
#include<iostream>
using namespace std;
class Person
{
public:
    void sum() const
    {
        int a = 1;
        int b = 2;
        cout << a + b << endl;
    };
    void sum()
    {
        int a = 2;
        int b = 4;
        cout << a + b << endl;
    };
};
int main()
{
    Person p;
    const Person q;
    p.sum();
    q.sum();
    return 0;
}
```

# 字符串相等问题

```cpp
#include <iostream>
using namespace std;

int main()
{
    char str1[] = "hello world";
    char str2[] = "hello world";

    const char str3[] = "hello world";
    const char str4[] = "hello world";

    const char* pstring1 = "hello world";
    const char* pstring2 = "hello world";

    //数组不对比不相等
    cout << boolalpha << (str1 == str2) << ',';
    cout << boolalpha << (str3 == str4) << ',';   
    cout << boolalpha << (pstring1 == pstring2) << endl;  //相等

    return 0;
}
```

## 字符函数

| **字符判断函数** |                     **作用**                     |
| :--------------: | :----------------------------------------------: |
|   `isalpha()`    |     判断字符`是否是字母`（'a'-'z' 'A'-'Z'）      |
|   `isdigit()`    |               判断字符`是否是数字`               |
|   `isspace()`    | 判断字符是否是`空格`、`制表符`、`换行等`标准空白 |
|   `isalnum()`    |            判断字符是否是字母或者数字            |
|   `ispunct()`    |               判断字符是`标点`符号               |
|   `islower()`    |       判断字符是否是`小写`字母（'a'-'z'）        |
|   `isupper()`    |       判断字符是否是`大写`字母（'A'-'Z'）        |

```cpp
// 使用字符函数统计字符串中各类型字符的个数
#include <cctype>
#include <iostream>
#include <string>
using namespace std;
int main() {
    string str;
    getline(cin, str);

    int whitespace = 0;
    int digits = 0;
    int chars = 0;
    int others = 0;

    // write your code here......
    for(int i = 0;i<str.size();i++)
    {
        if(isalpha(str[i]))
        {
            chars++;
        }
        else if(isdigit(str[i]))
        {
            digits++;
        }
        else if(isspace(str[i]))
        {
            whitespace++;
        }
        else {
            others++;
        }
    }
    cout << "chars : " << chars
        << " whitespace : " << whitespace
        << " digits : " << digits
        << " others : " << others << endl;

    return 0;
}
```

