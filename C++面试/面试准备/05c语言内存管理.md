# 内存管理

![C语言内存管理](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtWag4RMZqqBh24Iv7t2wkklKP44s1jHqABxXMrJ1PFGqWIrDf7Y8nDNpwgEZIyibkWp0JHVfaibJgg/640?wx_fmt=png)



# 代码区

> 存放程序编译后的`可执行`的`二进制代码`，`CPU`执行的`机器指令`，并且是`只读的`
>
> > `只读`
> >
> > 共享每次打开`exe文件`，都会指向一个`内存空间`



# 全局/静态区

> 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放
>
> > * 全局/静态区存储全局变量，静态变量，常量，该区变量在程序运行期间一直存在
> > * 程序结束由系统回收
> > * 已初始化的数据放在data段，未初始化的数据放到bss段
> > * 该去变量当未初始化时，会有默认值初始化





# 堆区

> 由开发者手动申请，手动释放，若不手动释放，程序结束后由系统回收，声明周期是整个程序运行期间，使用malloc进行堆内存申请，堆的总大小为机器的虚拟内存的大小
>
> > * 堆区由开发人员手动申请与释放，在释放之前，该快堆空间可一直使用
> > * 由程序员分配和释放，若程序员不释放，程序结束时由系统回收内存
> > * 堆空间一般没有软限制，只受限于硬件，会比栈空间更大，适宜存放较大数据



## 被调函数分配内存

```cpp
void allocateSpace(char * pp)
{ 
	char * temp = malloc(100);  //temp为局部变量
	memset(temp, 0, 100);
	strcpy(temp, "hello world"); //helloworld对方到堆区
	pp = temp;  //传入的参数和pp的地址并不相同，pp作为参数存放在栈中，函数结束释放内存
}


//1.利用高级指针
void allocateSpac2(char ** pp) ////使用二级指针，此时pp的地址与传入参数地址相同
{
	char * temp = malloc(100);
	memset(temp, 0, 100);
	strcpy(temp, "hello world");
	*pp = temp; //使用调用的指针来
	printf("aaa%s\n", *pp);
}
```



# 栈区

> 由编译器自动分配释放，存放函数的参数值，局部变量的值
>
> * 栈是一种先进后出的内存结构，由编译器自动分配释放数据
> * 主要存放函数的`形式参数值`，`局部变量`等
> * 函数`运行结束`，相应`栈变量`会被`自动释放`
> * `栈`空间`较小`，`不适合`大量数据存`放在栈中`
>
> 注意：`不要`返回`局部变量的地址`，在调用函数之后，局部变量就`已经被释放`，a的地址被销毁，在对指针p进行访问，就属于`非法访问内存`。



# 程序指令和程序数据分开原因

* 程序被加载到内存中之后，可以将数据和代码分别映射到两个内存区域。由于数据区域对进程来说是可读可写的，而指令区域对程序来讲是只读的，所以分区之后，可以将程序指令区域和数据区域分别设置成只读，这样就可以防止程序有意或无意被修改。
* 当系统中运行着多个同样的程序时，这些程序指令都是一样的，所以只需要在内存中保存一份程序指令即可，只是每一个程序运行中数据不一样而已，这样可以节省大量的内存。

![内存分配](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbtWag4RMZqqBh24Iv7t2wkkRda4M5yeJy3TEPIoaClbVtdoq4z7FZuiaoruEVN4m4mfI96qUeLJSkQ/640?wx_fmt=png)

# 宏定义

> * 宏定义和宏常量都是利用#define定义出来的内容
> * 在项目中，经常把一些短小而又频繁使用的函数写成宏函数
> * 宏函数没有普通函数参数压栈，跳转，返回等时间上的开销
>
> > 注意：宏函数要加括号，保证运算的完整，宏定义仅负责替换，不复制运行等相关操作。
>
> 可以把频繁使用并且短小的函数，写成宏函数，宏函数在编译阶段就替换源码，没有普通函数入栈出栈的开销，以空间换时间







# 参考资料

* [c内存管理](https://blog.csdn.net/qq_53144843/article/details/126888358)