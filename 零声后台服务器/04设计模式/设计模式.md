# 设计模式

> 设计模式实在软件开发中，经过`验证的`，用于`解决特定环境`下，`重复出现`的，`特定问题的解决`方案
>
> `解决问题`的`固定套路`，慎用设计模式
>
> * 满足设计原则后，`慢慢迭代`出来
> * 前提: 具体的需求既有`稳定点`，又有`变化点`

## 设计模式三大原则

### 单一职责原则

> 对一个类而言，应该仅有一个引起它变化的原因，其它就是将这个类所承担的职责单一化。
>
> 软件设计真正要做的事情就是，发现`根据需求`发现`职责`，并`把`这些`职责进行分离`，`添加新的类`，给当前类减负，越是这样的项目才越容易维护。

* 封装：封装指的是将`单一事物`抽象出来组合成一个类，而不是某些事物的集合。

### 开放封闭原则

> `软件实体`(类，模块，函数等)可以扩展，但是不可以修改。也就是说:对于扩展是开放的，对于修改是封闭的。
>
> > 每个小伙伴都是术业有专攻，但自己对他们的专业并不太了解，属于对自己来说是封闭的。但这个小伙伴抽象的概念，对外是开放的，每个伙伴都是这个功能的具体实现，但他们的技能又有所不同。

### 依赖倒转原则

> `高层模块`(上层应用，业务层的实现)不应该依赖`底层模块`(底层接口,如封装好的`API`，`动态库`等)，抽象`不`应该`依赖细节`，`细节`应该`依赖抽象`。
>
> `抽象`：指的是`抽象类`或`接口`

### 里氏代换原则

> 可以使用`子类`替换掉`父类`，同时功能也`不`会`受到影响`，`父类`实现了`复用`，`子类`也能够在`父类的基础上`添加`新的行为`。

* 抽象类中提供的接口是固定不变的
* 底层模块是抽象类的之类，继承了抽象类的接口，并且可以重写这些接口
* 高层模块想要实现某些功能，调用的是抽象类中的函数接口，并且是通过抽象类的父类指针引用其之类的实例对象(用子类类型替换父类类型)，实现多态。

# 工厂模式

> 实现类与类之间的解耦合，这样我们在创建对象的时候就变成拿来主义，使程序更加便于维护。

## 简单工厂模式

> * 创建一个新的类，可以将此类称之为工厂类，对于简单工厂模式来说，需要的工厂类仅此一个。
> * 在这个工厂类中添加一个公共的成员函数，通过这个函数来创建我们需要的对象，关于这个函数一般将其称之为工厂函数。
> * 首先创建一个工厂类对象，然后通过这个对象调用工厂函数，这样就可以生产处一个指定类型的实例对象。

![简单工厂模式](https://subingwen.cn/design-patterns/simple-factory/image-20220831172108896.png)

```cpp
#include <iostream>
using namespace std;

class AbstractSmile
{
public:
    virtual void transform() {}
    virtual void ability() {}
    virtual ~AbstractSmile() {}
};
// 人造恶魔果实· 绵羊形态
class SheepSmile : public AbstractSmile
{
public:
    void transform() override
    {
        cout << "变成人兽 -- 山羊人形态..." << endl;
    }
    void ability() override
    {
        cout << "将手臂变成绵羊角的招式 -- 巨羊角" << endl;
    }
};

// 人造恶魔果实· 狮子形态
class LionSmile : public AbstractSmile
{
public:
    void transform() override
    {
        cout << "变成人兽 -- 狮子人形态..." << endl;
    }
    void ability() override
    {
        cout << "火遁· 豪火球之术..." << endl;
    }
};

class BatSmile : public AbstractSmile
{
public:
    void transform() override
    {
        cout << "变成人兽 -- 蝙蝠人形态..." << endl;
    }
    void ability() override
    {
        cout << "声纳引箭之万剑归宗..." << endl;
    }
};

// 恶魔果实工厂类
enum class Type:char{SHEEP, LION, BAT};
class SmileFactory
{
public:
    SmileFactory() {}
    ~SmileFactory() {}
    AbstractSmile* createSmile(Type type)
    {
        AbstractSmile* ptr = nullptr;
        switch (type)
        {
        case Type::SHEEP:
            ptr = new SheepSmile;
            break;
        case Type::LION:
            ptr = new LionSmile;
            break;
        case Type::BAT:
            ptr = new BatSmile;
            break;
        default:
            break;
        }
        return ptr;
    }
};

int main()
{
    SmileFactory* factory = new SmileFactory;
    AbstractSmile* obj = factory->createSmile(Type::BAT);
    obj->transform();
    obj->ability();
    return 0;
}
```

## 工厂模式

> 简单工厂模式通过`switch`语句以及`case`，违背了`封闭原则`。`简单工厂`模式是只有一个`工厂类`，而`工厂模`式是有`很多工厂类`。

* `一个基类`： 包含一个`虚工厂函数`，用于`实现多态`
* `多个子类`，`重写`父类的`工厂函数`。每个`子工厂`负责一种`恶魔果实`，这相当于`再次解耦`，将`工厂类`的`职责`再次`拆分`，`细化`，`如果`要生产`新品种`，那么就`只需要`添加对应的`工厂类`，而`无需修`改`原有的代码`。

![工厂模式](https://subingwen.cn/design-patterns/factory/image-20220831172253762.png)

```c
#include <iostream>
using namespace std;

class AbstractSmile
{
public:
    virtual void transform() = 0;
    virtual void ability() = 0;
    virtual ~AbstractSmile() {}
};
// 人造恶魔果实· 绵羊形态
class SheepSmile : public AbstractSmile
{
public:
    void transform() override
    {
        cout << "变成人兽 -- 山羊人形态..." << endl;
    }
    void ability() override
    {
        cout << "将手臂变成绵羊角的招式 -- 巨羊角" << endl;
    }
};

// 人造恶魔果实· 狮子形态
class LionSmile : public AbstractSmile
{
public:
    void transform() override
    {
        cout << "变成人兽 -- 狮子人形态..." << endl;
    }
    void ability() override
    {
        cout << "火遁· 豪火球之术..." << endl;
    }
};

class BatSmile : public AbstractSmile
{
public:
    void transform() override
    {
        cout << "变成人兽 -- 蝙蝠人形态..." << endl;
    }
    void ability() override
    {
        cout << "声纳引箭之万剑归宗..." << endl;
    }
};

// 恶魔果实工厂类
class AbstractFactory
{
public:
    virtual AbstractSmile* createSmile() = 0;
    virtual ~AbstractFactory() {}
};

class SheepFactory : public AbstractFactory
{
public:
    AbstractSmile* createSmile() override
    {
        return new SheepSmile;
    }
    ~SheepFactory()
    {
        cout << "释放 SheepFactory 类相关的内存资源" << endl;
    }
};

class LionFactory : public AbstractFactory
{
public:
    // 工厂函数
    AbstractSmile* createSmile() override
    {
        return new LionSmile;
    }
    ~LionFactory()
    {
        cout << "释放 LionFactory 类相关的内存资源" << endl;
    }

};

class BatFactory : public AbstractFactory
{
public:
    // 工厂函数
    AbstractSmile* createSmile() override
    {
        return new BatSmile;
    }
    ~BatFactory()
    {
        cout << "释放 BatFactory 类相关的内存资源" << endl;
    }
};

int main()
{
    // 在main()函数中实例化一个生成一个工厂类
    AbstractFactory* factory = new BatFactory;
    AbstractSmile* obj = factory->createSmile();
    obj->transform();
    obj->ability();
    return 0;
}

```

## 抽象工厂模式

> `提供`一个`抽象的基类`，然后在它的之类中`完成各种型号`的船的`组装`，每个`子类`对应的就是`一条生产线`。

![抽象工厂模式](https://subingwen.cn/design-patterns/abstract-factory/image-20220903225145620.png)

* ShipBody类：船体的抽象类
* Weapon类：武器的抽象类
* Engine类：动力系统抽象类
* AbstractFactory类：抽象工厂类：在子工厂类中生产不同型号的战船，和ShipBody,Weapon,Engine有依赖关系，在工厂函数中创建了它们的实例对象，和Ship类有依赖关系，在工厂函数中创建了它的实例对象

Ship类可以和ShpiBody，Weapon，Engine可以是聚合关系，也就是组合关系

* 组合关系：析构Ship类对象的时候，也释放了ShipBody，Weapon,Engine对象
* 聚合关系：析构Ship对象的时候，没有释放ShipBody，Weapon,Engine对象

```c
#include <iostream>
#include <string>
using namespace std;

// 船体
class ShipBody
{
public:
    virtual string getShipBody() = 0;
    virtual ~ShipBody() {}
};

class WoodBody : public ShipBody
{
public:
    string getShipBody() override
    {
        return string("用<木材>制作轮船船体...");
    }
};

class IronBody : public ShipBody
{
public:
    string getShipBody() override
    {
        return string("用<钢铁>制作轮船船体...");
    }
};

class MetalBody : public ShipBody
{
public:
    string getShipBody() override
    {
        return string("用<合金>制作轮船船体...");
    }
};

// 武器
class Weapon
{
public:
    virtual string getWeapon() = 0;
    virtual ~Weapon() {}
};

class Gun : public Weapon
{
public:
    string getWeapon() override
    {
        return string("配备的武器是<枪>...");
    }
};

class Cannon : public Weapon
{
public:
    string getWeapon() override
    {
        return string("配备的武器是<自动机关炮>...");
    }
};

class Laser : public Weapon
{
public:
    string getWeapon() override
    {
        return string("配备的武器是<激光>...");
    }
};

// 动力
class Engine
{
public:
    virtual string getEngine() = 0;
    virtual ~Engine() {}
};

class Human : public Engine
{
public:
    string getEngine() override
    {
        return string("使用<人力驱动>...");
    }
};

class Diesel : public Engine
{
public:
    string getEngine() override
    {
        return string("使用<内燃机驱动>...");
    }
};

class Nuclear : public Engine
{
public:
    string getEngine() override
    {
        return string("使用<核能驱动>...");
    }
};

// 轮船类
class Ship
{
public:
    Ship(ShipBody* body, Weapon* weapon, Engine* engine) :
        m_body(body), m_weapon(weapon), m_engine(engine) 
    {
    }
    string getProperty()
    {
        string info = m_body->getShipBody() + m_weapon->getWeapon() + m_engine->getEngine();
        return info;
    }
    ~Ship() 
    {
        delete m_body;
        delete m_engine;
        delete m_weapon;
    }
private:
    ShipBody* m_body = nullptr;
    Weapon* m_weapon = nullptr;
    Engine* m_engine = nullptr;
};

// 工厂类
class AbstractFactory
{
public:
    virtual Ship* createShip() = 0;
    virtual ~AbstractFactory() {}
};

class BasicFactory : public AbstractFactory
{
public:
    Ship* createShip() override
    {
        Ship* ship = new Ship(new WoodBody, new Gun, new Human);
        cout << "<基础型>战船生产完毕, 可以下水啦..." << endl;
        return ship;
    }
};

class StandardFactory : public AbstractFactory
{
public:
    Ship* createShip() override
    {
        Ship* ship = new Ship(new IronBody, new Cannon, new Diesel);
        cout << "<标准型>战船生产完毕, 可以下水啦..." << endl;
        return ship;
    }
};

class UltimateFactory : public AbstractFactory
{
public:
    Ship* createShip() override
    {
        Ship* ship = new Ship(new MetalBody, new Laser, new Nuclear);
        cout << "<旗舰型>战船生产完毕, 可以下水啦..." << endl;
        return ship;
    }
};

int main()
{
    AbstractFactory* factroy = new StandardFactory;
    Ship* ship = factroy->createShip();
    cout << ship->getProperty();
    delete ship;
    delete factroy;
    return 0;
}
```

> 抽象工厂模式适用于比较复杂的多变的业务场景，总体上就是给一系列功能相同但是属性会发生变化的组件(例如：船体材料，武器系统，动力系统)添加一个抽象类，这样就非常方便后续的扩展，再搭配工厂类就可以创建处我们需要的对象

# 单例模式

> 全局范围内，某个类的实例有且只有一个，通过这个实例向其他模块提供数据的全局访问，这种模式就叫单例模式。单例模式的典型应用就是任务队列。

```cpp
// 定义一个单例模式的类
class Singleton
{
public:
    // = delete 代表函数禁用, 也可以将其访问权限设置为私有
    Singleton(const Singleton& obj) = delete;
    Singleton& operator=(const Singleton& obj) = delete;
    static Singleton* getInstance();
private:
    Singleton() = default;
    static Singleton* m_obj;
};
```



## 饿汉模式

> 饿汉模式就是类在`加载时`就`立刻`进行实例化，这样就得到一个`唯一可用`的`实例化`

```cpp
// 饿汉模式
class TaskQueue
{
public:
    // = delete 代表函数禁用, 也可以将其访问权限设置为私有
    TaskQueue(const TaskQueue& obj) = delete;
    TaskQueue& operator=(const TaskQueue& obj) = delete;
    static TaskQueue* getInstance()
    {
        return m_taskQ;
    }
private:
    TaskQueue() = default;
    static TaskQueue* m_taskQ;
};
// 静态成员初始化放到类外部处理
TaskQueue* TaskQueue::m_taskQ = new TaskQueue;

int main()
{
    TaskQueue* obj = TaskQueue::getInstance();
}
```



## 懒汉模式

> 懒汉模式是在`类加载`的时候`不去`创建这个`唯一的实例`，而是在`需要使用`的时候`再进行实例化`

```cpp
// 懒汉模式
class TaskQueue
{
public:
    // = delete 代表函数禁用, 也可以将其访问权限设置为私有
    TaskQueue(const TaskQueue& obj) = delete;
    TaskQueue& operator=(const TaskQueue& obj) = delete;
    static TaskQueue* getInstance()
    {
        if(m_taskQ == nullptr)
        {
            m_taskQ = new TaskQueue;
        }
        return m_taskQ;
    }
private:
    TaskQueue() = default;
    static TaskQueue* m_taskQ;
};
TaskQueue* TaskQueue::m_taskQ = nullptr;
```

## 线程安全问题

> 对于饿汉模式是没有线程安全问题，此模式在访问单例模式的时候，这个对象就已经诶创建出来。而对于懒汉模式，若三个线程同时申请，很可能出现三个实例对象。最常见的解决方案就是使用互斥锁。

```cpp
class TaskQueue
{
public:
    // = delete 代表函数禁用, 也可以将其访问权限设置为私有
    TaskQueue(const TaskQueue& obj) = delete;
    TaskQueue& operator=(const TaskQueue& obj) = delete;
    static TaskQueue* getInstance()
    {
        TaskQueue* queue = m_taskQ.load();  
        if (queue == nullptr)
        {
            // m_mutex.lock();  // 加锁: 方式1
            lock_guard<mutex> locker(m_mutex);  // 加锁: 方式2
            queue = m_taskQ.load();
            if (queue == nullptr)
            {
                queue = new TaskQueue;
                m_taskQ.store(queue);
            }
            // m_mutex.unlock();
        }
        return queue;
    }

    void print()
    {
        cout << "hello, world!!!" << endl;
    }
private:
    TaskQueue() = default;
    static atomic<TaskQueue*> m_taskQ;
    static mutex m_mutex;
};
atomic<TaskQueue*> TaskQueue::m_taskQ;
mutex TaskQueue::m_mutex;

int main()
{
    TaskQueue* queue = TaskQueue::getInstance();
    queue->print();
    return 0;
}
```

> 懒汉模式的缺点是在创建实例对象时有安全问题，但这样可以较少内存的浪费(如果用不到就不去申请)，饿汉模式相反，在我们不需要这个实例对象的时候，它已经被创建出来，占用了一块内存，对于现在的计算机而言，内存容量都是足够大的，这个缺陷可以被无视。

# 原型模式

> 克隆是一种最直接，最快捷的创建新对象的方式，它不仅隐藏了创建新对象的诸多细节，还保留了源对象的属性信息，保证了这两个多想能够一模一样

![原型模式](https://www.subingwen.cn/design-patterns/prototype/image-20220902005822196.png)

```cpp
#include <iostream>
using namespace std;

class GermaSoldier
{
public:
    virtual GermaSoldier* clone() = 0;
    virtual string whoAmI() = 0;
    virtual ~GermaSoldier() {}
};

class Soldier66 : public GermaSoldier
{
public:
    GermaSoldier* clone() override
    {
        return new Soldier66(*this);
    }
    string whoAmI() override
    {
        return string("我是杰尔马66的超级士兵!!!");
    }
};

class Soldier67 : public GermaSoldier
{
public:
    GermaSoldier* clone()
    {
        return new Soldier67(*this);
    }
    string whoAmI() override
    {
        return string("我是杰尔马67的超级士兵!!!");
    }
};

int main()
{
    GermaSoldier* obj = new Soldier66;
    GermaSoldier* soldier = obj->clone();
    cout << soldier->whoAmI() << endl;
    delete soldier;
    delete obj;

    obj = new Soldier67;
    soldier = obj->clone();
    cout << soldier->whoAmI() << endl;
    delete soldier;
    delete obj;
}
```



# 建造者模式



# 适配器模式

> 将一个类的接口转换为用户希望的另一个接口，使不兼容的对象能够相互配合在一起工作，起到桥梁纽带的作用。

# 组合模式

> 将对象组合成树型结构以表示`整体-部分`的层次结构，使用户对单个对象和组合对象的使用具有一致性。

# 装饰模式

> 动态地给一个对象添加一些额外饿职责，它提供了用子类扩展功能的一个活的替代，比派生一个子类更加灵活。

# 桥接模式

> 将抽象部分与它的实现部分分离，使它们都可以独立地变化

# 代理模式

> 为其他对象提供一种代理以控制这个对象的访问。

# 外观模式

> 定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化该子系统的使用。

# 亨元模式

> 提供大量细粒度对象共享的有效方法。

# 职责链模式

> 

# 命令模式

> 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。

# 迭代器模式



# 中介者模式

> 用一个中介对象来封装一系列的对象交互，它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改变对象间的交互。

# 备忘录模式

> 在不破坏封装性的前提下，捕获一个对象的内部状态，并存储这个状态，从而可以在以后将该对象恢复到原先保存的状态。

# 观察者模式

> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并被自动更新。

# 策略模式

> 定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化。

# 状态模式

> 允许一个对象在其内部状态改变时改变它的行为。

# 模版方法模式

> 定义一个操作中的算法骨架，而降一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤。

# 访问者模式

> 表示一个作用于某对象结构中国的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作。



# 生成器模式

> 将一个复杂类的表示与其构造相分离，使其相互构建过程得到不同的表示

>`化繁为简`，`逐个击破`。分步骤创建复杂的对象，并`允许`使用`相同的代码`生成`不同类型`和`形式的对象`，称为`生成器模式`(也叫`建造者模式`)
>
>在做项目时，想改先画`UML类图`，再`写程序`s







# 参考资料

* 爱编程的大丙
* 零声教育– 设计模式