

# 查找

> 在`数据集合`中寻找`满足条件`的数据`元素`的过程称为`查找`

* 查找表: 用于查找的`数据集合`称为查找表
* 静态查找表: 查找表中的数据，而`无需动态`的`修改查找表`
* 关键字:数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找的结果应该是唯一的
* 平均查找长度`ASL`(`Average Search length`)，在查找过程中，一次`查找`的长度是只需要比较的`关键字次数`，而平均查找长度则是`查找过程`中进行关键字的`比较次数`的平均值

$$
\sum_{i=1}^{n}{P_i}{C_i}
$$

* `n`：查找表的`长度`
* `P `是查找第`i`个数据元素的`概率`，通常认为查找`任何一个`元素的`概率相同`
* `C`是找到`第i个数据`元素所需进行的比较`次数`

## 顺序查找

>* 顺序表和链表都适用
>* 

```cpp
typedef struct
{
	Elemtype* elem;  //元素空间机制，建表按照实际长度分配，
	int TableLen; //表的长度
}SSTable;
int Search_Seq(SSTable ST, Elemtype key)
{
	ST.elem[0] = key;
	for (int i = ST.TableLen; ST.elem[i] != key; --i)
	{
		return i;//返回搜索到的key所在的i
	}
}
```

# 有序表查找

## 折半查找

>又称为折半查找，它仅适用于有序的顺序表

```cpp
//折半查找
int Binary_search(SeqList L, Elemtype key)
{
	int low = 0,high = L.TableLen-1,mid;
	while (low<=high)
	{
		mid = (low + high) / 2; //取中间位置
		if (L.elem[mid] == key)  //搜索到为止
		{
			return mid;
		}
		else if (L.elem[mid] > key)
		{
			high = mid - 1;   // 前半部分继续查找
		}
		else
		{
			low = mid + 1;   //后半部分继续查找
		}
	}
	return -1;  //查找失败，返回-1
}
```

## 插值查找

> 根据查找的`关键字key`与查找表中`最大最小记录`的关键字比较的`查找方法`，其核心在于插值的计算公式
>
> * 若要在取值范围`0~10000`之间`100个`元素`从小到大`均匀分布的数组中`查找5`
> * 需要考虑从`数组下标较小`的开始查找

* 修改`mid折半`查找`取中代码`

```cpp
mid = low+(key-L.elem[low])/(L.elem[high]-L.elem[low])*(high-low);
```





## 斐波那契查找

> (`Fibonacci Search`): 
>
> * 递归的精髓在于能够将原始问题转换为属性相同但规模较小的问题
> * 在递归调用过程中，系统为每一层的返回点，局部变量，传入实参等开辟了递归工作栈来进行数据存储，递归次数过多容易造成栈溢出等，而其效率不高的原因是递归调用过程中包含了很多重复的计算



### 斐波那契

```cpp
/* 斐波那契数列的实现 */
int Fib(int n)
{
	if (n == 0)
	{
		return 0; //边界条件
	}
	else if (n == 1)
	{
		return 1; // 边界条件
	}
	else
	{
		return Fib(n - 1) + Fib(n - 2);//递归表达式
	}
}
```

### 查找







## 分块查找

>

```cpp

```

## 散列表

yuu





