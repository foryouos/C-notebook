---
title: 泛化程序设计
date: 2023-02-23 22:04:51
tags:
- Git
- 编程语言
categories:
- [计算机科学, Git分布式版本控制]
cover :
---
#### 泛型程序设计

* 编程不依赖于具体数据类型的程序
* 将算法从特定的数据结构中抽象出来，成为通用的C++的模块为泛型程序设计奠定关键基础
#### 概念
* 在`C++ STL`库中用\"概念"来界定具备一定功能的数据类型
	* 将“可以比大小的所有数据类型\(有比较运算符)“这一概念记为Comparable
	* 将”具有共有的复制构造函数并可以用‘=’赋值的数据类型“这一概念记为Assignable
	* 将“可以比大小,具有公有的复制构造函数并可以用’=‘赋值的所有数据类型”这个概念记作Sortable
* 对于两个不同的概念A和B，如果概念A所需求的所有功能也是概念B所需求的功能，那么就说概念B是概念A的子概念
	* sortable激是Comparable的子概念，也是Assignable的子概念
#### 模型
* (model):符合一个概念的数据类型称为该概念的模型
	* int是Comparable概念的模型
	* 静态数组类型不是Assignable概念的模型(无法用"="给整个静态数组赋值")
#### 用概念做模型参数名

* 为概念赋予一个名称，并使用该名称作为模版参数名
```C++
//表示insertionSort这样一个函数模版的原型
template <class Sortable>
void insertSort(Sortable a[],int n);
```
![STL组件之间的关系](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbu9gl5iaXpZfp2frL7XicianeJicK9Nz6uMGxGSxUcoLpRlEfENRibf3S2jFia1qA04ORlHquAl1z3JEXCQ/0?wx_fmt=png "STL组件之间的关系")

#### `STL`

* `STL`:标准模板库(Standard Template Library简称`STL`)提供了一些非常常用的数据结构和算法，`STL`定义了一套概念体系，为泛化程序设计提供了逻辑基础
* `STL`中的各个类模版，函数模版的参数都是用这个体系概念来规定的
* 使用`STL`模版，类型参数既可以是`C++标准库`中已有的类型，也可以是自己定义的类型-只要这些类型是所要求概念的模型

#### `STL`的基本组件

* 容器(container)
* 迭代器(iterator)

* 函数对象(function object)
* 算法(algorithms)
#### 迭代器
* Iterators(迭代器)是算法和容器的桥梁
	* 将迭代器作为算法的参数，通过迭代器来访问容器而不是把容器直接作为算法的参数
* 将函数对象作为算法的参数而不是将函数所执行的运算作为算法的一部分
* 使用STL中提供的或自定义的迭代器和函数对象，配合STL算法，可以组合出各种各样的功能
* 迭代器泛化的指针
* 提供了顺序访问容器中每个元素的方法
* 可以使用"++"运算符来获得指向下一个元素的迭代器
* 可以使用\"\*"运算符访问一个迭代器所指向的元素，如果元素类型是类或结构体，还可以使用\"->"运算符来直接访问该元素的一个成员
* 有些迭代器还支持通过"--"运算符获得指向上一个元素的迭代器
* 有些迭代器是泛化的指针:指针也具有同样的特性，因此指针本身就是一种迭代器
* 使用独立于STL容器的迭代器，需要包含头文件<iterator>
#### 容器
* 容纳，包含一组元素的对象
* 基本容器类模版
	* 顺序容器
	> array(数组),vector(向量),deque(双端队列),forward_list(单链表),list(列表)
	* \(有序)关联容器
	> set(集合),multiset(多重集合),map(映射),multimap(多重映射)
	* 无序关联容器
	> unordered_set(无序集合),unordered_multiset(无序多重集合)
	> unordered_map(无序映射),unorder_multimap(无序多重映射)
* 容器适配器
> stack(栈),queue(队列),priority_queue(优先队列)
* 使用容器，需要包含对应的头文件
#### 函数对象
* 一个行为类似函数的对象，对它可以像调用函数一样调用
* 函数对象时泛化的函数：任何普通的函数和任何重载了“()”运算符的类的对象都可以作为函数对象使用
* 使用`STL`的函数对象，需要包含头文件`<functional>`

#### 算法举例:transform 算法

* transform算法遍历first和last两个迭代器所指向的元素，
* 将每个元素的值作为函数对象op的参数
* 将op的返回值通过迭代器result顺序输出
* 遍历完成后result迭代器指向的是输出的最后一个元素的下一个位置，transform会将迭代器返回
```C++
template <class Inputlterator,class Outputlterator,class UnaryFunction>
Outputlterator transform(InputLterator first,Inputlterator,Outputlterator result,UnaryFunction op)
{
	for(;first!=last;++first,++result)
	{
		*result = op(*first);
	}
	return result;
}
```

#### 算法\(algorithms)
* STL包含70多种算法
	* 例如:排序算法，消除算法，计数算法，变换算法，置换算法和容器管理等
* 可以广泛用于不同的对象和内置的数据类型
* 使用STL算法，需要包含头文件<algorithm>
#### 例:从标准输入读入几个整数，存入向量容器，输出相反数
```C++
#include <iostream>
#include <vector>		//向量
#include <iterator>  //迭代器
#include <algorithm>  //算法
#include <functional> //函数对象
using namespace std;
int main(void)
{
	const int N = 5;
	vector<int> s(N);  //容器
	for (int i = 0; i < N; i++)
	{
		cin >> s[i];
	}
	transform(s.begin(), s.end(), ostream_iterator<int>(cout, "## "), negate<int>());  //算法，negate取相反数
	cout << endl;
	return 0;
}
```
#### 迭代器
* 迭代器是算法和容器的桥梁
	* 迭代器用作访问容器中的元素
	* 算法不直接操作容器中的数据，而是通过迭代器间接操作
* 算法和容器独立
	* 添加新的算法，无需影响容器的实现
	* 添加新的容器，原有的算法也能适用
#### 输入迭代器和输出迭代器
* 输入迭代器
	* istream_iterator<T>
	* 以输入流(如cin为参数构造)
	* 可用\*\(p++)获取下一个输入的元素
* 输出流迭代器
	* ostream_iterator<T>
	* 构造时需要提供输出流\(如cout)
	* 可用\(\*p++)=x将x输出到输出流
* 二者都属于适配器
	* 适配器是用来为已有对象提供新的接口的对象
	* 输入流适配器和输出流适配器为流对象提供了迭代器的接口
```C++
//从标准输入读入几个实数，分别输出它们的平方
#include <iostream>
#include <iterator>
#include <algorithm>
using namespace std;

//求平方的函数
double square(double x)
{
	return x * x;
}
int main(void)
{
	//从标准输入读入若干个实数，分别将它们的平方输出
	transform(istream_iterator<double>(cin), istream_iterator<double>(), ostream_iterator<double>(cout, "\t"), square);
	//头，尾，写入结果，函数处理
	//头：输入流迭代器，double， 关联到cin
	//尾没有构造函数，不给为空，----指向输入流结束
	//写入结果:cout  "\t"两个输出项之间的分隔符
	//函数处理:square

	cout << endl;
}
```
#### 迭代器的区别
* 两个迭代器表示一个区间:\[`p1,p2`\)  包含p1不包含p2
* STL算法常以迭代器的区间作为输入，传递输入数据
* 合法的区间
	* p1经过n次(n>0)自增(++)操作后满足p1==p2;
* 区间包含p1，但不包含p2





