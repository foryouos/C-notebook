# string基础

## string

> `C++`字符`串类`，容器类，可以吧字符串当做普通类型使用

## 构造函数



```cpp
string s();  //生成空的字符串s
string s(str); //拷贝构造函数
string(const string& str); // 生成str的复制品
//将字符串str中从pos到长度为strlen,作为str初值
string s(const string& str, size_type pos,strlen); 
//舒婷str的前n个字符串初始化为字符串s的初值
string s(const char* cstr, size_type n);
//生成一个字符串包含num个c字符
string s(int num,char c);
string s(beg,end);//以区间beg,end内的字符作为字符串s的初值
s.~string();  //销毁所有字符，释放空间
    
```

## 操作函数

```cpp
=，assign();  //赋以新值
//assign第一个参数为复制的自付出啊，第二第三位返回，开始和结束范围
swap();//交换两个字符串的内容
+=，append(),push_back(); //在尾部添加字符
//push_back()在结尾添加单个字符，仅一个
insert();  //插入字符
//需要指定插入的索引insert(1,"hello");
erase(int nStart,int nEnd); //删除start-End的字符
clear();        //删除全部字符
replace(); //替换字符
//需要添加索引
s.replace(1,2,"hello"); 
//将索引1开始到2替换为后面的hello
+   //串联字符串
==,!=,<,<=,>,>=,compare(); //比较字符串
size(),length();   //返回字符串数量
max_size(); //返回字符串饿可能最大个数
empty(); //判断字符串是否为空
capacity(); //返回重新分配之前的字符容量,会为string重新分配内存
reserve();  //保留一定量内容，以容纳一定数量字符
[],at();   //存取单一字符
// []并不检查 索引是否有效，有效索引0~str.length()
>>,getline(); //从stream读取某值
<<         //将某值写入stream
copy();   //将某值复制为一个c_string
to_str();  //将内容以以c_string返回
data();   //将内容以字符数组形式返回
substr(); //返回某个子字符串，提取部分字符串
// 添加开始和结束索引
s.substr(5,6); //5~6的字符串
s.substr(11);  //从11往后的子串
// 搜索
// 搜索符合条件的字符区间，返回第一个字符的索引，没找到目标返回npos --多数为size大小
find();   //从正面查找
rfind();  //倒序查找
find_first_of();  //寻找第一个
find_last_of();   //寻找最优一个
find_first_not_of(); //寻找第一个之后的元素，输出其索引
find_last_not_of();  //寻找非第二个之后的元素，输出其索引

begin(),end(); //提供类似STl的迭代器支持
rbegin(),rend(); //逆向迭代器
get_allocator();  //返回配置器
```

## 使用`STL`算法

```cpp
//初始化值
string name = "marius";
// 将字符串全部转为大写
trandform(name.begin(),name.end(),name.begin(),toupper);
// 升序排列字符串
sort(name.begin(),name.end());
//字符串反转
reverse(name.begin(),name.end());
// 删除空白字符
bool iswhitespace(char ch)
{
    return ch ==''|| ch == '\t'|| ch=='\v'|| ch=='\r'|| ch =='\n';
}
newend = remove_if(name.begin(),name.end(),iswhitespace);
```

# LeetCode 1768

## 01交替合并字符串

>给你两个字符串 `word1` 和 `word2` 。请你从 `word1` 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。
>
>返回 **合并后的字符串** 。
>
>>```
>>输入：word1 = "abc", word2 = "pqr"
>>输出："apbqcr"
>>解释：字符串合并情况如下所示：
>>word1：  a   b   c
>>word2：    p   q   r
>>合并后：  a p b q c r
>>```
>>

> > ```
> > 输入：word1 = "ab", word2 = "pqrs"
> > 输出："apbqrs"
> > 解释：注意，word2 比 word1 长，"rs" 需要追加到合并后字符串的末尾。
> > word1：  a   b 
> > word2：    p   q   r   s
> > 合并后：  a p b q   r   s
> > ```

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;
string mergeAlternately(string word1, string word2) {
    //交替字符串合并
    // 新的字符串，每次
    string word; //存储新的字符串
    //取字符串最大的
    int word1_size = word1.size();
    int word2_size = word2.size();
    int min_length = word1_size > word2_size ? word2_size : word1_size;
    //对字符串长度进行遍历
    int i = 0;
    //max_length取最小的
    for (i = 0; i < min_length; i++)//当字符串1不为空时，依次对双方将数据添加到word当中
    {
        //在字符串尾部添加数据
        word += word1[i];
        word += word2[i];
    }
    // 判断谁的长度大于还有数据，将数据合并到末尾
    if (word1_size>word2_size)
    {
        //使用字符串索引提取
        word += word1.substr(i, -1); //不能用区间
    }
    else if (word1_size < word2_size)
    {
        word += word2.substr(i, -1);
    }
    return word;
}
int main(void)
{
    string a = "ab";
    string b = "pqrs";
    string c = mergeAlternately(a, b);
    cout << c.data() << endl;
	return 0;
}
```

