---
title : 利用汇编挖掘C++本质
date : 2023年3月1日09:07:51
description : 汇编，
cover : https://s2.loli.net/2023/02/28/EQjtHoq9xe21cya.jpg
---
#### 汇编的用途
* 掌握编程语言，代码的本质
* 破解
* ...

#### 汇编

> 汇编语言与机器语言`一一对应`，每一条机器语言指令都有与之`对应`的汇编指令
> 高级语言可以通过编译得到汇编语言/机器语言，但`汇编语言/机器语言`几乎`不`可能还原成高级语言
> Visual studio 在调试下Ctrl 


```assembly
9: 	int arrray[] = { 1,2,3 }; //C++语言
//汇编-   地址  机器指令 汇编代码
00007FF7BA87191C C7 45 08 01 00 00 00 mov         dword ptr [arrray],1  
00007FF7BA871923 C7 45 0C 02 00 00 00 mov         dword ptr [rbp+0Ch],2  
00007FF7BA87192A C7 45 10 03 00 00 00 mov         dword ptr [rbp+10h],3  
```

![image-20230301095815829](E:\学习笔记\Markdown\C-notebook\汇编01\assets\image-20230301095815829.png)

* 编译型语言(不依赖虚拟机)
> C\C++\OC\Switft
* 脚本语言
> Python\JS\PHP
* 编译型语言(依赖虚拟机)
> Java\Ruby

#### Visual studio 2022常用快捷键

![image-20230301110325907](E:\学习笔记\Markdown\C-notebook\汇编01\assets\image-20230301110325907.png)
#### 为什么C++支持函数重载
> 采用name mangling 或者name decoration技术
- [x] C++编译器默认会对符号名(比如函数名)进行改变，修饰
- [x] 重载时会生成多个不用的函数名，不同编译器(MSVC,g++)有不同的生成规则
#### 默认参数
* 默认参数必须从右边开始
* 如果同时有声明，实现，默认参数只能放在函数声明中
#### 指针存储函数名
```c
void func(int v1,void(*p)(int)) //函数指针
{
	p(v1);
}
void test(int a)
{
	cout << "test(int) - "<< a <<endl;
}
int main(void)
{
	void(*p)(int) = test; //指针存储函数名
	p(10); 
	func(20,test);
}
```
#### extern \"C"
> 被extern \"C"修饰的代码会按照C语言的方式去编译，用在C和C++混合开发
```cpp
#include  <iostream>
using namespace std;
extern "C" void func() //使用C编译函数重载
{

}
extern "C" void func(int v)
{

}
//或者
extern "C"  //使用大括号C编译内部
{
	void func()
	{

	}
	void func(int v)
	{

	}
}
int main()
{

	return 0;
}
//“func”: 无法重载具有外部 "C" 链接的

```
> 如果函数同时有声明和实现，要让函数声明被`extern "C"`修饰，函数实现可以不修饰(声明和实现都放，或者放声明处)
#### cpp使用c语言开源库
```c
//math.c文件
int sum(int v1, int v2)
{
	return v1 + v2;
}
int delta(int v1, int v2)
{
	return v1 - v2;
}
```
```cpp
#include  <iostream>

using namespace std;
//或者
extern "C"  //使用c来编译c函数
{
	int sum(int v1, int v2);
	int delta(int v1, int v2);
}
int main()
{
	cout << sum(10, 20) << endl;
	cout << delta(30, 20) << endl;

	return 0;
}
/*
输出
30
10
*/
```
##### c文件写入头文件
```c
//math.h
#pragma once
int sum(int v1, int v2)
{
	return v1 + v2;
}
int delta(int v1, int v2)
{
	return v1 - v2;
}
```
```cpp
#include  <iostream>

using namespace std;
//或者
extern "C"  //使用c来编译头文件
{
#include "math.h" 
}
int main()
{
	cout << sum(10, 20) << endl;
	cout << delta(30, 20) << endl;

	return 0;
}
/*
输出
30
10
*/
```
#### 宏定义
* C++默认会定义宏`#define _cplusplus`,将此应用到都文件中判断是否为C++环境来决定是否用C编译
```cpp
#pragma once

#ifdef _cplusplus
extern "C"
{
#endif //_cplusplus

	int sum(int v1, int v2)
	{
		return v1 + v2;
	}
	int delta(int v1, int v2)
	{
		return v1 - v2;
	}

#ifdef _cplusplus
}
#endif //_cplusplus
```
#### `#pragma once`
* 我们经常使用`#ifndef,#define,#endif`来防止头文件的内容被重复包含
* `#pragma once`可以防止整个文件的内容被重复包含
#### 内联函数与宏
* 内联函数和宏，都可以减少函数调用的开销
* 对比宏，内联函数多了语法检测和函数特性
#### C++有些表达式可以被赋值
```cpp
int a = 1;
int b = 2;
//赋值给了a
(a = b) = 3;
//赋值给了 b
(a < b ? a : b) = 4;
```















