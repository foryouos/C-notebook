---
title : 利用汇编挖掘C++本质
date : 2023年3月1日09:07:51
description : 汇编，
cover : https://s2.loli.net/2023/02/28/EQjtHoq9xe21cya.jpg
---
#### 汇编的用途
* 掌握编程语言，代码的本质
* 破解
* ...

#### 汇编

> 汇编语言与机器语言`一一对应`，每一条机器语言指令都有与之`对应`的汇编指令
> 高级语言可以通过编译得到汇编语言/机器语言，但`汇编语言/机器语言`几乎`不`可能还原成高级语言
> Visual studio 在调试下右键`转汇编`


```assembly
9: 	int arrray[] = { 1,2,3 }; //C++语言
//汇编-   地址  机器指令 汇编代码
00007FF7BA87191C C7 45 08 01 00 00 00 mov         dword ptr [arrray],1  
00007FF7BA871923 C7 45 0C 02 00 00 00 mov         dword ptr [rbp+0Ch],2  
00007FF7BA87192A C7 45 10 03 00 00 00 mov         dword ptr [rbp+10h],3  
```

![image-20230301095815829](E:\学习笔记\Markdown\C-notebook\汇编01\assets\image-20230301095815829.png)

* 编译型语言(不依赖虚拟机)
> `C\C++\OC\Swift`
* 脚本语言
> `Python\JS\PHP`
* 编译型语言(依赖虚拟机)
> Java\Ruby

#### Visual studio 2022常用快捷键

![image-20230301110325907](E:\学习笔记\Markdown\C-notebook\汇编01\assets\image-20230301110325907.png)
#### 为什么C++支持函数重载
> 采用`name mangling` 或者`name decoration`技术
- [x] C++编译器默认会对`符号名`(比如函数名)进行改变，修饰
- [x] 重载时会生成多个不用的函数名，不同编译器(`MSVC,g++`)有不同的生成规则

#### 默认参数

* 默认参数必须从右边开始
* 如果同时有声明，实现，默认参数只能放在函数声明中
#### 指针存储函数名
```c
void func(int v1,void(*p)(int)) //函数指针
{
	p(v1);
}
void test(int a)
{
	cout << "test(int) - "<< a <<endl;
}
int main(void)
{
	void(*p)(int) = test; //指针存储函数名
	p(10); 
	func(20,test);
}
```
#### extern \"C"
> 被extern \"C"修饰的代码会按照`C`语言的方式去编译，用在C和C++混合开发
```cpp
#include  <iostream>
using namespace std;
extern "C" void func() //使用C编译函数重载
{

}
extern "C" void func(int v)
{

}
//或者
extern "C"  //使用大括号C编译内部
{
	void func()
	{

	}
	void func(int v)
	{

	}
}
int main()
{

	return 0;
}
//“func”: 无法重载具有外部 "C" 链接的

```
> 如果函数同时有声明和实现，要让函数声明被`extern "C"`修饰，函数实现可以不修饰(声明和实现都放，或者放声明处)
####  `cpp`使用C语言开源库

```c
//math.c文件
int sum(int v1, int v2)
{
	return v1 + v2;
}
int delta(int v1, int v2)
{
	return v1 - v2;
}
```
```cpp
#include  <iostream>

using namespace std;
//或者
extern "C"  //使用c来编译c函数
{
	int sum(int v1, int v2);
	int delta(int v1, int v2);
}
int main()
{
	cout << sum(10, 20) << endl;
	cout << delta(30, 20) << endl;

	return 0;
}
/*
输出
30
10
*/
```
##### `C`文件写入头文件

```c
//math.h
#pragma once
int sum(int v1, int v2)
{
	return v1 + v2;
}
int delta(int v1, int v2)
{
	return v1 - v2;
}
```
```cpp
#include  <iostream>

using namespace std;
//或者
extern "C"  //使用c来编译头文件
{
#include "math.h" 
}
int main()
{
	cout << sum(10, 20) << endl;
	cout << delta(30, 20) << endl;

	return 0;
}
/*
输出
30
10
*/
```
#### 宏定义
* C++默认会定义宏`#define _cplusplus`,将此应用到都文件中判断是否为C++环境来决定是否用C编译
```cpp
#pragma once

#ifdef _cplusplus
extern "C"
{
#endif //_cplusplus

	int sum(int v1, int v2)
	{
		return v1 + v2;
	}
	int delta(int v1, int v2)
	{
		return v1 - v2;
	}

#ifdef _cplusplus
}
#endif //_cplusplus
```
#### `#pragma once`
* 我们经常使用`#ifndef,#define,#endif`来防止头文件的内容被重复包含
* `#pragma once`可以防止整个文件的内容被重复包含
#### 内联函数与宏
* 内联函数和宏，都可以减少函数调用的开销
* 对比宏，内联函数多了语法检测和函数特性
#### C++有些表达式可以被赋值
```cpp
int a = 1;
int b = 2;
//赋值给了a
(a = b) = 3;
//赋值给了 b
(a < b ? a : b) = 4;
```
####  `const`
```cpp
//const的含义，const修饰的是右边的内容
int age = 10;
const int *p1 = &age;
//修饰*p1是常量，而p1地址可以改
int const *p2 = &age; //同p1,const可以和类型互换位置
int * const p3 = &age;
//const修饰右边的内容p3是地址常量，不变，而*p3可以修改
const int * const p4 = &age;
int const * const p5 = &age;
//p4和p5等价，地址和*p4,*p5都是常量不能变
```

#### 引用
* 引用的本质就是弱化了的指针
* 一个引用占用一个指针的大小
* 在C语言中，使用指针(Pointer)可以间接获取，修改某个变量的值
* 在C++中，使用引用(Reference)可以起到指针类似的额功能
**注意**:
* 引用相当于变量的别名(基本数据类型，枚举，结构体，类，数组等，都可以有引用)
* 对引用做计算，就是对引用所指向的变量做计算
* 在定义的事后就必须初始化，一旦指向了某个变量，就不可以再改变，\"从一而终"
* 可以利用引用初始化另一个引用，相当于某个变量的多个别名
* 不存在(引用的引用，指向引用的指针，引用数组)
* 引用存在的价值:比指针更安全，函数返回值可以被赋值
* const必须卸载&符号的左边，才能算常引用
##### `const`引用的特点
* 可以指向临时数据(常量，表达式，函数返回值等)
* 可以指向不同类型的数据
* 作为函数参数时(此规则也适用于`const指针`)
- [x] 可以接受`const`和非`cons`实参(`非const`引用，只能接受`非const`实参)
- [x]  可以跟非const引用构成重载
* 当常引用指向了`不同类型`的数据时，会产生`临时变量`，即引用指向的并不是初始化时的那个变量
```cpp
	int age = 10;
	const long& aAge = age;
	age = 30;
```
```assembly
00007FF71556184D C7 45 04 0A 00 00 00 mov         dword ptr [rbp+4],0Ah  
	00007FF715561854 8B 45 04             mov         eax,dword ptr [rbp+4]  
	00007FF715561857 89 45 44             mov         dword ptr [rbp+44h],eax  
	00007FF71556185A 48 8D 45 44          lea         rax,[rbp+44h]  
	00007FF71556185E 48 89 45 28          mov         qword ptr [rbp+28h],rax  
	00007FF715561862 C7 45 04 1E 00 00 00 mov         dword ptr [rbp+4],1Eh  
```
****
```cpp
#include  <iostream>
#include "math.h"
using namespace std;
/* 
两者引用：机器码相同，汇编相同
*/
int main()
{
	int age = 22;
	int* p = &age;
	*p = 25;
	cout << age << endl;
	int& ref = age;
	ref = 30;
	cout << age << endl;
	return 0;
}
```
```assembly
 9: 	int& ref = age;
00007FF759091914 48 8D 45 04          lea         rax,[rbp+4]
00007FF759091918 48 89 45 28          mov         qword ptr [rbp+28h],rax
	10: 	ref = 30;
00007FF75909191C 48 8B 45 28          mov         rax,qword ptr [rbp+28h]
00007FF759091920 C7 00 1E 00 00 00    mov         dword ptr [rax],1Eh
   11: 	int* p = &age;
00007FF6CD505214 48 8D 45 04          lea         rax,[rbp+4]  
00007FF6CD505218 48 89 45 28          mov         qword ptr [rbp+28h],rax  
    12: 	*p = 25;
00007FF6CD50521C 48 8B 45 28          mov         rax,qword ptr [rbp+28h]  
00007FF6CD505220 C7 00 19 00 00 00    mov         dword ptr [rax],19h 

```
##### 常引用数组
```cpp
//数组名arr起始就是数组的地址，也是数组首元素的地址
// 数组名arr可以看做是指向数组首元素的指针(int *)
int arr[] = {1,2,3};
// int (&ref)[3] = arr;
int * const &ref = arr; //常量要用常引用
```
#### 汇编语言
##### 汇编语言的种类
* 8086汇编(16bit)
* x86汇编（32bit)
* `x64汇编(64bit)`
* ARM回避那(嵌入式，移动设备)
* ...
* `x64`汇编根据编译器不同，两种书写格式
> `Intel`:
> AT&T

##### AT&T汇编 VS Intel汇编

![image-20230302073341484](E:\学习笔记\Markdown\C-notebook\汇编01\assets\image-20230302073341484.png)

#### 寄存器与内存

假设内存中有块红色内存空间的值是3，现在想把它的值加1，并将结果存储到蓝色内存空间 

* `cpu`首先会将红色内存空间的值放到EAX寄存器中:mov eax, 红色内存空间
* 然后让eax寄存器与1相加: add eax,1
* 最后将值赋值给内存空间: mov 蓝色内存空间,eax
```cpp
	int a = 5;
	a = a + 1;
```

```assembly
    10: 	int a = 5;
00007FF6E7DA520D C7 45 04 05 00 00 00 mov         dword ptr [rbp+4],5  
    11: 	a = a + 1;
00007FF6E7DA5214 8B 45 04             mov         eax,dword ptr [rbp+4]  
00007FF6E7DA5217 FF C0                inc         eax  
00007FF6E7DA5219 89 45 04             mov         dword ptr [rbp+4],eax 
```

#### x64寄存器Register
* RAX(包含EAX)\REX\RCX\RDX：通用寄存器
* 32bit:EAX\EBX\ECX\EDX：通用寄存器
* 16bit:AX\BX\CX\DX:通用寄存器
* x64一个寄存器8个字节
* R开头的寄存器是64bit的，占8字节
* E开头的寄存器是32bit的，占4个字节
#### C++内联汇编
```cpp
#include <iostream>
using namespace std;

int main()
{
	int a = 10;
	//双下划,C++嵌入汇编执行
	__asm
	{
		mov eax, 10
	}
}
```
#### `x86`汇编重要指令
* `mov` dest,src
> 将src的内容赋值给dest，类似于dest = src
* `[地址值]`
> * 中括号[]里面放的都是内存地址

	* `word`是2字节，`dword`是4字节(double word),`qword`是八字节(quad word)

* `call` 函数地址	
> * 调用函数，并不是真实地址
>
> * CPU大小端模式，大部分都是小端模式
> 小端模式:高高低低，高字节放高地址，低字节放低地址
> 一个变量的地址值，是它所在字节地址中的最小值

* `lea` `dest`, `[地址值]`
> 将地址赋值给`dest`，类似`dest = 地址值`


* `ret `
> 函数返回

* `xor` `op1` , `op2`
> 将`op1`和`op2``异或`的结果赋值给`op1`,类似于`op1` = `op1` ^ `op2`

* `add`  `op1`,`op2`
> 类似于`op1 = op1 + op2`

* `sub` `op1`,`op2`
> 类似于`op1` = `op1` - `op2`

* `inc `op
> 自增，类似于 op = op + 1

* `dec` op
> 自减，类似于op = op - 1

* `jmp` 内存地址
	
	* 跳转到某个内存地址去执行代码
	* j开头的一般都是跳转，大多是带条件的跳转，一般跟`test`，`cmp`等指令配合使用
	参考权威:[Intel白皮书](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)[^1]
* `cmp` `eax` , b
> `cmp`是``compare`的简称，比较`eax`和`b`的值是否相等

#### 跳转指令表格

| JE, JZ                  |                 | 结果为零则跳转(相等时跳转)     |      | ZF=1           |
| ----------------------- | --------------- | ------------------------------ | ---- | -------------- |
| equal                   | zero            |                                |      |                |
|                         |                 |                                |      |                |
| JNE, JNZ                |                 | 结果不为零则跳转(不相等时跳转) |      | ZF=0           |
| not equal               | not  zero       |                                |      |                |
|                         |                 |                                |      |                |
| JS                      |                 | 结果为负则跳转                 |      | SF=1           |
| sign(有符号\有负号)     |                 |                                |      |                |
|                         |                 |                                |      |                |
| JNS                     |                 | 结果为非负则跳转               |      | SF=0           |
| not sign(无符号\无负号) |                 |                                |      |                |
|                         |                 |                                |      |                |
| JP, JPE                 |                 | 结果中1的个数为偶数则跳转      |      | PF=1           |
| parity even             |                 |                                |      |                |
|                         |                 |                                |      |                |
| JNP, JPO                |                 | 结果中1的个数为偶数则跳转      |      | PF=0           |
| parity odd              |                 |                                |      |                |
|                         |                 |                                |      |                |
| JO                      |                 | 结果溢出了则跳转               |      | OF=1           |
| overflow                |                 |                                |      |                |
|                         |                 |                                |      |                |
| JNO                     |                 | 结果没有溢出则跳转             |      | OF=0           |
| not overflow            |                 |                                |      |                |
|                         |                 |                                |      |                |
| JB, JNAE                |                 | 小于则跳转 (无符号数)          |      | CF=1           |
| below                   | not above equal |                                | <    |                |
|                         |                 |                                |      |                |
| JNB, JAE                |                 | 大于等于则跳转 (无符号数)      |      | CF=0           |
| not below               | above  equal    |                                | >=   |                |
|                         |                 |                                |      |                |
| JBE, JNA                |                 | 小于等于则跳转 (无符号数)      |      | CF=1 or ZF=1   |
| below equal             | not above       |                                | <=   |                |
|                         |                 |                                |      |                |
| JNBE, JA                |                 | 大于则跳转(无符号数)           |      | CF=0 and ZF=0  |
| not below equal         | above           |                                | >    |                |
|                         |                 |                                |      |                |
| JL, JNGE                |                 | 小于则跳转 (有符号数)          |      | SF≠ OF         |
| little                  | not great equal |                                | <    |                |
|                         |                 |                                |      |                |
| JNL, JGE                |                 | 大于等于则跳转 (有符号数)      |      | SF=OF          |
| not little              | great  equal    |                                | >=   |                |
|                         |                 |                                |      |                |
| JLE, JNG                |                 | 小于等于则跳转 (有符号数)      |      | ZF=1 or SF≠ OF |
| little equal            | not great       |                                | <=   |                |
|                         |                 |                                |      |                |
| JNLE, JG                |                 | 大于则跳转(有符号数)           |      | ZF=0 and SF=OF |
| not little equal        | great           |                                | >    |                |

#### 汇编符号说明

![汇编符号说明](E:\学习笔记\Markdown\C-notebook\汇编01\assets\汇编符号说明.png "汇编符号说明")
#### 参考的C++变量名规范
* 全局变量:`g_`
* 成员变量：`m_`
* 静态变量: `s_`
* 常量: `c_`
#### 类补充
* struct默认public
* class 默认private
##### 如何利用指针间接访问所指向量的成员变量
* 从指针中取出对象的地址
* 利用对象的地址 `+` 成员变量的偏移量计算出成员变量的地址
* 根据成员变量的地址访问成员变量的存储空间
* 类函数默认会被赋值为ccccccc，
* cc -> int3 :起到断点的作用
* 中断:interrupt
#### 内存空间的布局
>  每个应用都有自己独立的内存空间
* 栈空间
> 每调用一个函数就会给它分配一段连续的栈空间，等函数调用完毕后会自动回收这段栈空间
> 自动分配和回收
* 堆空间
> 需要主动去申请和释放，在程序运行过程，为了能够自由控制内存的声明周期，大小，会经常使用堆空间的内存
* 代码区(段)
> 用于存放代码
* 全局区(数据段)
> 用于存放全局变量等
#### 对初始内存初始化
> memset函数是将较大的数据结构(比如对象，数组等)内存清零的比较快的方法
```cpp
int *p = (int *)malloc(sizeof(int)*10);
//*p=0;//并不能全部清零，仅前四个字节
memset(p,0,40);//从p地址开始，连续个字节，都设置为0
```
```cpp
Person person;
person.m_id = 1;
person.m_age = 20;
person.m_height = 180;
memset(&person,0,sizeof(person));  //赋值person为零
```
##### new的初始化
```cpp
int *p1 = new int;      //未被初始化
int *p2 = new int();    //被初始化为0
int *p3 = new int(5);    //被初始化为5
int *p4 = new int[3];    //数组元素未被初始化
int *p5 = new int[3]();  //3个数组元素都被初始化为0
int *p6 = new int[3]{};  //3个数组元素都被初始化为0
int *p7 = new int[3]{ 5 } //数组首元素被初始化为5，其它元素被初始化为零
```
#### malloc不会调用类的构造&析构函数
```cpp
#include <iostream>
using namespace std;
struct Person
{
	int m_age;

	Person()
	{
		cout << "Person()" << endl;
	}
	~Person()
	{
		cout << "释放Person()" << endl;
	}
};
int main(void)
{
	Person person; //会调用默认构造函数
	Person* p = new Person; //申请空间也会调用默认构造函数
	delete p;
	//malloc并不调用默认构造函数,
	Person* q = (Person*)malloc(sizeof(Person));
	free(q); //也不会调用析构函数
	return 0;
}
/*
Person()
Person()
释放Person()
释放Person()
*/
```
#### 成员变量的初始化
* **全局区默认初始化为0**
* 如果自定义了构造函数，除了全局区，其他内存空间的成员变量默认都不会被初始化，需要开发人员手动初始化。
```cpp
#include <iostream>
using namespace std;

struct Person
{
	int m_age;
};
Person g_person;  //全局变量初始化为0
int g_age;  //全局变量默认初始化为 0
int main(void)
{
	//Person person; //堆空间：没有初始化成员变量

	//堆空间:没有初始化成员变量
	Person* p0 = new Person;
	//堆空间:成员变量初始化为0，//如果有构造函数则不进行初始化
	Person* p1 = new Person();
	cout << g_age << endl;
	cout << g_person.m_age << endl;
	//cout << person.m_age << endl;
	cout << p0->m_age << endl;
	cout << p1->m_age << endl;

	return 0;
}
/*输出:
0
0
-842150451
0
*/
```




















[^1]:https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html

参考资料:


