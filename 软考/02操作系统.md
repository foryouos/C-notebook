# 操作系统

> `6~8分`
>
> 能够有效组织和管理系统中的各种`软/硬`件资源，合理地组织计算机系统工作流程，`控制程序`的执行，并且向用户提供一个`良好`的工作`环境`和`友好`的`接口`。
>
> * 通过`资源管理`，提高`计算机系统效率`
> * 改善人际界面
>
> 特性: `并发性`，`共享性`，`虚拟性`，`不确定性`。
>
> * 进程管理：`进程状态`，`前驱图`，`PV操作`，`死锁`，`银行家算法`
> * 存储管理：`段页`式存储，`页面置换`算法，
> * 文件管理：`绝对`路径与`相对`路径，`索引`文件，`位示图`
> * 作业管理
> * 设备管理：`虚设备`与`SPOOLING技术`

# 分类

> * `批处理/批作业`： 按照指令依次执行，较少人机交互，提高计算机效率
> * `分时处理操作系统`： 分时处理把`CPU`分成`很多碎片`，把`碎片`分给`作业`依次执行，就是分时系统分时操作
> * `实时操作系统`：系统运行`足够块`，在`可接受`的`时间范围内`，提交作业马上会产生结果
> * `网络操作系统`：网络相关功能：`共享文件夹`，`网络打印机`，`存储服务器`等
> * `分布式操作系统`：除具有网络操作系统功能外，同时具有`更高`的`可靠性`，`可扩展性`，`健壮性`等。分布式系统：网络中多个计算机，它们的`物理位置`可能`不在同一个区域`，多个计算机组合在一起，形成网络系统，通过分布式系统来进行资源的管理和调度。
> * `微机系统`：笔记本PC机基本上都属于微型计算机
> * `嵌入式操作系统`：工厂的工控机，安装嵌入式芯片，不像微机系统那么庞大，但它的性能，可靠性会好一些，可以根据实时性去进行定制，裁剪。拥有独立地实验场景。

# 进程管理

> 主要是对`处理器`进行管理，为了`提高CPU的利用率`而采用`多道程序技术`。通过`进程管理`来`协调多道程序`间的`关系`。使`CPU得到充分`的利用。从而`引入进程`的概念。`进程`是`资源分配的基本单位`，是一个程序在一个数据集上的一次运行。程序是一组指令的集合，而`线程`是进程能够`并发运行`的各个部分。

## 进程

> `进程`是程序在一个`数据集合上`运行的`程序`，它是系统进行`资源分配`和`调度`的一个`独立单位`。它由`程序块`，`进程控制块PCB`和`数据块`三部分组成

## 进程和程序区别

> `进程`是`程序`的一次执行过程，`没有程序`就`没有进程`。
>
> `程序`是`完成某个特定功能`的一系列`程序语句`的`集合`，只要不被破坏，它就永远存在，`程序`是一个`静态`的概念，而进程是一个`动态`的概念，它由创建而产生，完成任务后`因撤销`而`消亡`，`进程`是系统进行`资源分配`和`调度`的`独立单位`，而`程序不是`。

> 三态模型：
>
> * `运行态`：进程已经获得了`CPU资源`且`正在执行`。
> * `就绪态`：进程已经`万事具备`，`只欠`东风(`CPU`资源)。
> * `等待态`：等待`其它需要运行`的资源`准备好`。例如`等待用户输入`，或者从`外设获`取相关信息过来的`状态`。

![三态模型](./assets/0201%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B.png)

![五态模型](./assets/02%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B.jpg)

## 进程同步与互斥

> 进程的并发性带来了异步性(各个并发的进程以不可预知的速度向前推进)，而有的进程需要有次序的相互配合来完成作业，所以有了进程同步。

![进程同步与互斥](./assets/image-20230923183414425.png)

> 进程控制：是指对`进程创建`到消亡的整个生命过程进行全程控制
>
> `原语`：为了实现`一定目的`，由`一系列指令`组成`指令集`，其原子特性是不可再分割的。原语里面的指令，要么都执行，要么`都不执行`，执行完成以后就实现了一个目的的代码。
>
> `同步`：两个进程`协作`去做某一件事情。结果一定是`两个进程`都达到了目前的目标，只要有一个没有达到或者没有实现，另一个`必须等待`。
>
> `互斥`：某个资源被其中一个进程占用以后，其他进程就`不能`使用这个资源，`必须等待`。
>
> `临界资源`：进程`都需要使用`的资源，称为`临界资源`，一般来说是互斥的，不会同时允许去使用
>
> `临界区`：临界区指的就是程序帧要`使用临界资源`的代码。

## 互斥机制准则

* `空闲让进`
* `忙则等待`
* `有限等待`
* `让权等待`

## `PV`操作

> * 临界资源：`诸进程间`需要互斥方式对其进行`共享的资源`，如打印机，磁带机等
> * 临界区：每个进程中`访问临界资源`的那段代码称为`临界区`
>   * `进入区`：为了进入临界区使用临界资源，在进入区要检查可否进入临界区，如果可以进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区
>   * `临界区`：进程中访问临界资源的那段代码 又称 临界段
>   * `退出区` ：将正在访问临界区的标志清除
>   * `剩余区`：代码中的其余部分。
> * 信号量：是一种`特殊的变量` , S大于等于0表示某资源的可用数，S小于0则其绝对值表示阻塞队列中等待该资源的进程数。
> * `P`是荷兰语的`Passeren`,`V`是荷兰语的`Verhoog`
> * `P`是`申请资源`的操作 `输入`  ，`V`是`释放资源`的操作`输出` 
> * `P` 也是 `等待申请` 操作，`V`也是 `完成释放`

```c
// 申请临界资源  打印机  时 
P(S)  //请求到资源 (相当于程序输入)  申请到原有资源 --
使用打印机   // 执行相关操作
V(S)  // 释放资源(相当于程序的输出)  原有资源 ++ 
```

![PV操作与前驱图](./assets/02PV%E6%93%8D%E4%BD%9C.png)

![PV操作例题](./assets/image-20230923185000803.png)





## 线程

> 某个`进程`下`多个线程`可以`共享`同一进程的`资源`，但是`每个线程`都独自拥有`程序计数器`，一组`寄存器`，`栈`等必须的资源。

## 进程资源图

![进程资源图](./assets/image-20231002144429225.png)

# 死锁

> `进程`管理是操作系统的`核心`，如果设计不当，就会出现`死锁问题`，如果一个进程在等待一件不可能发生的事情，则该进程就陷入`死锁`。
>
> 系统给所有进程分配`所`需资源数`少一个`，`系统留`一个资源。系统就`不会`陷入`死锁问题`

## 刀叉问题

![刀叉问题](./assets/image-20231003104220453.png)

```java
 public static void main(String[] args) {
    Object knife = new Object(); //刀
    Object fork = new Object(); //叉
    Thread t1 = new Thread(() -> {
        synchronized (knife) {
            System.out.println("张三拿到刀了!");
            synchronized (fork) {
                System.out.println("张三刀和叉都拿到了!吃牛排!");
            }
        }
    });
    Thread t2 = new Thread(() -> {
        synchronized (fork) {
            System.out.println("小美拿到叉了!");
            synchronized (knife) {
                System.out.println("小美刀和叉都拿到了!吃牛排!");
            }
        }
    });
    t1.start();
    t2.start();
}
```

## 死锁条件

![多线程死锁](./assets/02%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81.png)

* `互斥`
* `环路等待`
* `保持`和`等待`
* `不剥夺`

## 死锁避免

> 解决`死锁`最简单可靠的`办法`，就是`打破循环等待`。

* `有序资源`分配法
* `银行家算法`

## 银行家算法

> 当一个进程`申请使用资源`的时候，`银行家算法`通过先 **试探** 分配给该进程资源，然后通过`安全性算法`判断分配后的系统`是否处于`安全状态，若`不安全`则`试探分配作废`，让该进程`继续等待`。

![资源分配](./assets/02%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D.png)

# 存储管理

> * `上/下界寄存器保护`：上界寄存器中存放的是作业的转入地址，下界寄存器转入的是作业的结束地址，形成的物理地址要求是 ： `上界寄存器 < = 物理地址 < = 下界寄存器`
> * 基址/ 限长寄存器保护 ： 基址寄存器中存放的是作业的转入地址；限长寄存器转入的是作业的结束地址。形成的物理地址要求：基址寄存器 < = 物理地址 < 机址寄存器 + 限长寄存器

## 四级缓存

![四级缓存](./assets/02%E5%9B%9B%E7%BA%A7%E7%BC%93%E5%AD%98.png)

## 位示图

> 利用二进制中的一位来表示磁盘中一个盘快的使用情况，当其值为 0 时，表示对应的盘快空闲，为1时表示已经分配。也有相反的都是使用二进制位状态位表示盘快饿分配状况。

## 页式存储

> 将一个`进程`的`地址空间`划分为`若干个`大小`相等`的`区域`，成为` 页`；将`主存空间`划分成与`页相同`大小的`若干个物理块`，成为 `块`，或`页框`
>
> * 页表 (页面映射表) ： 每个页在页表中占一个表项，记录程序中的某页在内存中对应的物理块号
> * 地址变换机构 ： 利用页表吧用户程序中的逻辑地址变换成内存中的物理地址。
>
> ![页式存储](./assets/02%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8.png)
>
> 将`程序`和内存`均划分`为同样大小的块，以`页为`单位(固定页大小，无形中拆分了`程序功能模块`将`程序`调入内存。
>
> `逻辑地址` =` 页号 `+ `页内地址`
>
> `物理地址` = `页帧号` +` 页内地址`
>
> 优点：`利用率高`，`碎片小`，`分配`及`管理简单`
>
> 缺点：`增加`了`系统开销`，可能产生`抖动现象`

![页号](./assets/image-20230923191144908.png)

## 抖动

> 如果`分配`给进程的`存储数量`小于进程所需要的`最小值`，进程的运行将会`很频繁`地产生`缺页中断`，这种频繁非常高的页面置换现象称为`抖动`。`页面内存`与`外存`之前`频繁调度`，以至于`调度页面所需时间`比`进程实际运行时间`还多，此时`系统效率`极具`下降`，导致`系统崩溃`。这种现象称为 `颠簸`或`抖动`。

## 段式存储

> 按用户作业中的自然段来划分逻辑空间，然后调入内存，段的长度可以不一样
>
> 段表要记录: `断号`，`段长`，`基址`
>
> 优点： 多道程序共享内存，各段程序修改互不影响
>
> 缺点：`内存利用率低`，`内存碎片`浪费`大`

![段页式](./assets/02%E6%AE%B5%E9%A1%B5%E5%BC%8F.jpg)

## 段页式存储

> `段式`和`页式`的`综合体`，`先分段`，`再分页`。`1个`程序有`若干个段`，`每个段`中可以`有若干页`，`每个页`的`大小相同`，但`每个段`的`大小不同`。

![段页式存储](./assets/image-20230923192826127.png)

> * 优点： `空间浪费小`，存储`共享容易`，`存储保护容易`，`能动态连接`
> * 缺点：由于管理软件的增加，复杂性和开销也随之增加，需要的`硬件`以及`占用的内容`也有`所增加`，使得`执行速度`大大`下降`。

## 虚拟存储管理

> * `时间`局限性：程序中某条指令一旦执行，`不久的将来`可能会被再次执行
> * `空间`局限性 ： 一旦程序`访问`了`某个存储单元`，不久的将来，其`附近的存储单元`也可能被访问。

## 页面置换算法

> * `最优`(Optimal ,OPT)算法
> * `随机算法`( `Rand` )
> * `先进先出` ( `FIFO `)算法：可能会产生`抖动`，
> * 最近最少使用`LRU`算法：不会`抖动`，`LRU`的理论依据是`局部性原理`

## 磁盘管理

> `存取时间 = 寻道时间+等待时间`，`寻道时间`是指`磁头移动`到`磁道所需`的时间；`等待时间`为`等待读写的删去`转到`磁头下方所用的时间`。

![磁盘管理](./assets/image-20230923193424866.png)

![垂直盘快](./assets/02%E5%9E%82%E7%9B%B4%E7%9B%98%E5%BF%AB.png)

> 读取磁盘数据的时间包含三个部分 ：
>
> * 找磁道的时间
> * 找块(扇区)的时间，即旋转延迟的时间
> * 传输时间
>
> 磁盘读取时间 = 寻道时间 + 旋转延迟时间 + 传输时间

## 磁盘调度算法

* `先来先`服务（`FCFS`) ： 谁先申请，响应谁
* `最短寻道`时间优先(`SSTF`) ： 当前情况，剩下的申请中谁离磁道数近就先相应谁
* `扫描`算法（`SCAN`) ：(电梯算法) 从内到外，从外到内双向扫描中间所遇到的所有申请，来进行处理
* `循环`扫描（`CSCAN`算法) : 从内到外 或者 从外到内 单向扫描中间所遇到的所有申请，来进行处理。

> `读取磁盘数据`实现应包含的`三个部分`
>
> * `找磁道`的时间
> * 找`块(扇区)`的时间，即`旋转延迟`时间
> * `传输时间`



# 作业管理

![作业管理](./assets/image-20230923195240583.png)

## 作业调度算法

* `先来先服务`
* `时间片轮转法`
* `短作业优先法`
* `最高优先权优先法`
* `高响应比优先法`：`作业等待时间/执行时间`

# 文件管理

> 文件管理的目的： 负责管理外存储器上的信息，是用户可以`按名`高效，快捷和方便地存储信息。

## 索引文件结构(文件的物理结构)

### 连续结构

> 将逻辑上连续的文件信息依次连续存放在连续编号的物理块上(顺序表)，只要指导文件的起始物理块号和文件的长度就很方便进行文件的存取

### 链式结构(串联结构)

> 将逻辑上连续的文件信息存放在不连续的物理块上，每个物理块设有一个指针指向下个物理块(链表)
>
> 只知道文件的第一个物理块号，就可以按链指针查找整个文件

### 索引结构(重点)

> 采用`索引结构`时，将`逻辑`上`连续的文件信息`存放在`不连续的物理块`中，系统为`每个文件`建立一`张索引表`，
>
> `索引表记录了文件信息`所在的`逻辑块号`对应的`物理块号`，并将`索引表`的`起始地址`放在与`文件对应`的`文件目录项`中。

> 分为`13个`索引节点，从`0`开始 
>
> * 一级间接索引：`256K`
> * 物理盘快 ：` 64M`
> * 三级间接索引： `16G`

![索引文件结构](./assets/02%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png)

> `Linux`系统的`目录结构`，
>
> 考察`相对路径`，`绝对路径`。

![树形目录结构](./assets/image-20230923195534117.png)

![操作管理](./assets/image-20231002144944202.png)

# 设备管理

> 设备管理技术主要包括 ：` 通道`，`DMA`，`缓冲`，`Spooling技术`。

## `数据传输控制`方式

![数据传输控制方式](./assets/image-20230923200227670.png)

## SPOOLING技术

> `SPOOLing`是关于`慢速字符设备`如何与`计算机主机`交换信息的一种技术，通常称为`假脱机技术`，`SPOOLing`技术通过`磁盘实现`
>
> Spooling技术用一类物理设备模拟另一类物理设备，使独占使用的设备变成多态虚拟设备，它也是一种速度匹配技术。
>
> Spooling系统中拥有一张作业表，用来登记进入系统的所有作业的作业名，状态和预输入表位置灯信息
>
> 每个用户作业拥有一张输入表用来登记作业的各个文件的情况，包括设备类，信息长度及存储位置灯。

### 组成

> `Spooling`系统由`预输入程序`，`缓输出程序`，`井管理程序`以及`输入输出井`组成。

![SPOOLing技术](./assets/image-20230923200422041.png)

> `输入`和`输出`并用于`存放从输入`的信息以及`作业执行`的结果，是系统在`辅助存储器`上`开辟`的`存储区域`。

### 输入井

> 输入井有4中状态：输入，收容，执行，完成
>
> * 输入：作业的信息正才能够输入设备上预输入
> * 收容：作业预输入结束但未被选中执行
> * 执行状态 ： 作业已被选中运行，运行过程中，它可从输入井中读取数据信息，也可向输出井写信息
> * 完成状态 ： 作业已经撤离，由系统进行善后处理。

# 微内核操作系统

> 微内核操作系统吧内核做的更小的操作系统，使系统的可靠性，稳定性和安全性得到提高，降低问题发生的概率，只把最核心的部分放入内核。

![微内核](./assets/02%E5%BE%AE%E5%86%85%E6%A0%B8.png)

# 人机界面

> 计算机用户界面发展经历了4个阶段：控制面板式用户界面，字符用户界面，图形用户界面及新一代用户界面。

## 图标设置准则

* 定义准确形象
* 表达符合的行为习惯
* 风格表现统一
* 使用配色的协调

# 参考资料

> * [PV操作](https://blog.csdn.net/tu_wer/article/details/120903321)
> * 希赛软考
> * [死锁](https://www.jianshu.com/p/105d76b69e15)
> * [存储管理](https://blog.csdn.net/m0_67601373/article/details/124648410)
> * [磁道管理](https://blog.51cto.com/u_15980166/6086560)
> * [文件管理](https://blog.csdn.net/soaipipiop/article/details/127375964)
> * [文件与作业管理人机界面](https://blog.csdn.net/soaipipiop/article/details/127326103)