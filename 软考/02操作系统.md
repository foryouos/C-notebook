# 操作系统

> `6~8分`
>
> 能够有效组织和管理系统中的各种`软/硬`件资源，合理地组织计算机系统工作流程，`控制程序`的执行，并且向用户提供一个`良好`的工作`环境`和`友好`的`接口`。
>
> * 通过`资源管理`，提高`计算机系统效率`
> * 改善人际界面
>
> 特性: `并发性`，`共享性`，`虚拟性`，`不确定性`。
>
> * 进程管理：`进程状态`，`前驱图`，`PV操作`，`死锁`，`银行家算法`
> * 存储管理：`段页`式存储，`页面置换`算法，
> * 文件管理：`绝对`路径与`相对`路径，`索引`文件，`位示图`
> * 作业管理
> * 设备管理：`虚设备`与`SPOOLING技术`

# 分类

> * `批处理/批作业`： 按照`指令依次`执行，减少人机交互，提高计算机效率
> * `分时处理操作系统`： 分时处理把`CPU`分成`很多碎片`，把`碎片`分给`作业`依次执行，就是分时系统分时操作
> * `实时操作系统`：系统运行`足够块`，在`可接受`的`时间范围内`，提交作业马上会产生结果
> * `网络操作系统`：网络相关功能：`共享文件夹`，`网络打印机`，`存储服务器`等
> * `分布式操作系统`：除具有网络操作系统功能外，同时具有`更高`的`可靠性`，`可扩展性`，`健壮性`等。
> * 分布式系统：网络中多个计算机，它们的`物理位置`可能`不在同一个区域`，多个计算机组合在一起，形成`网络系统`，通过分布式系统来进行`资源`的管理和`调度`。
> * `微机系统`：笔记本PC机基本上都属于微型计算机
> * `嵌入式操作系统`：工厂的工控机，安装嵌入式芯片，不像微机系统那么庞大，但它的性能，可靠性会好一些，可以根据实时性去进行定制，裁剪。拥有独立地实验场景。

# 进程管理

> 主要是对`处理器`进行管理，为了`提高CPU的利用率`而采用`多道程序技术`。通过`进程管理`来`协调多道程序`间的`关系`。使`CPU得到充分`的利用。从而`引入进程`的概念。`进程`是`资源分配的基本单位`，是一个程序在一个数据集上的一次运行。程序是一组指令的集合，而`线程`是进程能够`并发运行`的各个部分。

## 进程

> `进程`是程序在一个`数据集合上`运行的`程序`，它是系统进行`资源分配`和`调度`的一个`独立单位`。它由`程序块`，`进程控制块PCB`和`数据块`三部分组成

## 进程和程序区别

> `进程`是`程序`的一次执行过程，`没有程序`就`没有进程`。
>
> `程序`是`完成某个特定功能`的一系列`程序语句`的`集合`，只要不被破坏，它就永远存在，`程序`是一个`静态`的概念，而进程是一个`动态`的概念，它由创建而产生，完成任务后`因撤销`而`消亡`，`进程`是系统进行`资源分配`和`调度`的`独立单位`，而`程序不是`。

> 三态模型：
>
> * `运行态`：进程已经获得了`CPU资源`且`正在执行`。
> * `就绪态`：进程已经`万事具备`，`只欠`东风(`CPU`资源)。
> * `等待态`：等待`其它需要运行`的资源`准备好`。例如`等待用户输入`，或者从`外设获`取相关信息过来的`状态`。

![三态模型](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbsEcibd47DQia7ibYjMicEvylA9S1P3ZoTDIUBIkXnDicSD91hbHibSDYBUs4qKY3OSM8nic2SI7JenHibCvg/640?wx_fmt=png)

![五态模型](https://mmbiz.qpic.cn/mmbiz_jpg/ORog4TEnkbsEcibd47DQia7ibYjMicEvylA982IwqFuSOWXZLSLd8zPt0Sn1VTibxQ1fJ75EaJKGiaKKyvbBT4SpeyLA/640?wx_fmt=jpeg)

## 进程同步与互斥

> 进程的`并发性`带来了`异步`性(各个并发的进程以`不可预知`的速度向前推进)，而有的进程需要有次序的相互配合来完成作业，所以有了`进程同步`。

![进程同步与互斥](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbuIQJperDJ3XAtWsba2Pp2qdFTzxYx8ZcQLdgpUO3syev048ZuYCzmurgr9FxVgicsROfyibwg9ic1AQ/640?wx_fmt=png)

> 进程控制：是指对`进程创建`到`消亡`的整个生命过程进行`全程控制`
>
> `原语`：为了实现`一定目的`，由`一系列指令`组成`指令集`，其原子特性是不可再分割的。原语里面的指令，要么都执行，要么`都不执行`，执行完成以后就实现了一个目的的代码。
>
> `同步`：两个进程`协作`去做某一件事情。结果一定是`两个进程`都达到了目前的目标，只要有一个没有达到或者没有实现，另一个`必须等待`。
>
> `互斥`：某个资源被其中一个进程占用以后，其他进程就`不能`使用这个资源，`必须等待`。
>
> `临界资源`：进程`都需要使用`的资源，称为`临界资源`，一般来说是互斥的，不会同时允许去使用
>
> `临界区`：临界区指的就是程序执行`使用临界资源`的代码。

## 互斥机制准则

* `空闲让进`
* `忙则等待`
* `有限等待`
* `让权等待`

## `PV`操作

> * 临界资源：`诸进程间`需要互斥方式对其进行`共享的资源`，如打印机，磁带机等
> * 临界区：每个进程中`访问临界资源`的那段代码称为`临界区`
>   * `进入区`：为了进入`临界区`使用`临界资源`，在进入区要检查可否进入临界区，如果可以进入临界区，则应`设置`正在`访问临界区`的`标志`，以`阻止其他进程`同时进入临界区
>   * `临界区`：进程中`访问临界资源`的那段`代码` 又称 `临界段`
>   * `退出区` ：将`正在访问`临界区的`标志清除`
>   * `剩余区`：代码中的其余部分。
> * 信号量：是一种`特殊的变量` , S大于等于0表示某资源的可用数，S小于0则其绝对值表示阻塞队列中等待该资源的进程数。
> * `P`是荷兰语的`Passeren`,`V`是荷兰语的`Verhoog`
> * `P`是`申请资源`的操作 `输入`  ，`V`是`释放资源`的操作`输出` 
> * `P` 也是 `等待申请` 操作，`V`也是 `完成释放`

```c
// 申请临界资源  打印机  时 
P(S)  //请求到资源 (相当于程序输入)  申请到原有资源 --
使用打印机   // 执行相关操作
V(S)  // 释放资源(相当于程序的输出)  原有资源 ++ 
```

![PV操作与前驱图](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbsEcibd47DQia7ibYjMicEvylA9yQ3YhibSAQ9vgm1MmpKGfJwun4gQEllxk884xdPnInoyoBxGZLpNtbA/640?wx_fmt=png)

![PV操作例题](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbuIQJperDJ3XAtWsba2Pp2q8SicC4kq53ec59RqFm9fNBhwNibwSGypj5KdPlTF9QmERXsD9oXaD5vw/640?wx_fmt=png)

## 线程

> 某个`进程`下`多个线程`可以`共享`同一进程的`资源`，但是`每个线程`都独自拥有`程序计数器`，一组`寄存器`，`栈`等必须的资源。

## 进程资源图

![进程资源图](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbuIQJperDJ3XAtWsba2Pp2qsyNBHAqlVibXY6Gw2CMMibveg3cMUIia9p9RQV4wwz5aEaNdqejuBIx2Q/640?wx_fmt=png)

# 死锁

> `进程`管理是操作系统的`核心`，如果设计不当，就会出现`死锁问题`，如果一个进程在`等待`一件`不可能`发生的事情，则该进程就陷入`死锁`。
>
> 系统给`所有进程`分配`所`需资源数`少一个`，`系统留`一个资源。系统就`不会`陷入`死锁问题`

## 刀叉互斥问题

![刀叉问题](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbuIQJperDJ3XAtWsba2Pp2qZtBw6JqKeBKvicB1E3ERAxuG4YJHT5cvbP9yLMtCEic3LCT7Miagkibbhg/640?wx_fmt=png)

```java
 public static void main(String[] args) {
    Object knife = new Object(); //刀
    Object fork = new Object(); //叉
    Thread t1 = new Thread(() -> {
        synchronized (knife) {
            System.out.println("张三拿到刀了!");
            synchronized (fork) {
                System.out.println("张三刀和叉都拿到了!吃牛排!");
            }
        }
    });
    Thread t2 = new Thread(() -> {
        synchronized (fork) {
            System.out.println("小美拿到叉了!");
            synchronized (knife) {
                System.out.println("小美刀和叉都拿到了!吃牛排!");
            }
        }
    });
    t1.start();
    t2.start();
}
```

## 死锁条件

![多线程死锁](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbsEcibd47DQia7ibYjMicEvylA9Wqnib8jZWQD1sHGeQtkhoCEibIQiae9p4DzNPXfGphFOA40TIZbfMtQWw/640?wx_fmt=png)

* `互斥`
* `环路等待`
* `保持`和`等待`
* `不剥夺`

## 死锁避免

> 解决`死锁`最简单可靠的`办法`，就是`打破循环等待`。

* `有序资源`分配法
* `银行家算法`

## 银行家算法

> 当一个进程`申请使用资源`的时候，`银行家算法`通过先 **试探** 分配给该进程资源，然后通过`安全性算法`判断分配后的系统`是否处于`**安全**状态，若`不安全`则`试探分配作废`，让该进程`继续等待`。

![资源分配](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbsEcibd47DQia7ibYjMicEvylA9G9pF3Rqyzo2mIiaaO2R5jib87kjwFLib0m9e3OUUAIMsaObm68lic1ccBA/640?wx_fmt=png)

# 存储管理

> * `上/下界寄存器保护`：**上界**寄存器中存放的是作业的**转入**地址，**下界**寄存器转入的是作业的`结束`地址，形成的物理地址要求是 ： `上界寄存器 < = 物理地址 < = 下界寄存器`
> * 基址/ 限长寄存器保护 ： 基址寄存器中存放的是作业的转入地址；限长寄存器转入的是作业的结束地址。形成的物理地址要求：**基址寄存器 < = 物理地址 < 机址寄存器 + 限长寄存器**

## 四级缓存

![四级缓存](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbsEcibd47DQia7ibYjMicEvylA9OkTsM55xMgey80atp9l1uBONPJicwetKEvx1tXrnxwVCnKksGLhLMJQ/640?wx_fmt=png)

## 位示图

> 利用**二进制**中的一位来表示磁盘中一个盘快的使用情况，当其值为 0 时，表示对应的`盘块`空闲，为`1时`表示`已分配`。也`有相反`（此规则不统一）的都是使用二进制位状态位表示**盘块分配**状况。

## 页式存储

> 将一个`进程`的`地址空间`划分为`若干个`大小`相等`的`区域`，成为` 页`；将`主存空间`划分成与`页相同`大小的`若干个物理块`，成为 `块`，或`页框`
>
> * `页表 `(页面映射表) ： 每个页在页表中`占`一个`表项`，记录程序中的`某页`在内存中对应的`物理块号`
> * 地址`变换机构` ： 利用`页表`把用户程序中的`逻辑地址`变换成内存中的`物理地址`。
>
> ![页式存储](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbsEcibd47DQia7ibYjMicEvylA9dpibzAcjY9IeLrg0U7tkP5hw8r61iaKKfYp0t7sGLRa9WaqHiaUHxkA6A/640?wx_fmt=png)
>
> 将`程序`和内存`均划分`为同样大小的块，以`页为`单位(固定页大小，无形中拆分了`程序功能模块`将`程序`调入内存。
>
> `逻辑地址` =` 页号 `+ `页内地址`
>
> `物理地址` = `页帧号` +` 页内地址`
>
> 优点：`利用率高`，`碎片小`，`分配`及`管理简单`
>
> 缺点：`增加`了`系统开销`，可能产生`抖动现象`

![页号](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbuIQJperDJ3XAtWsba2Pp2qzaPJLpAXje2dX3do4iciaQmrLRiaqrnXanSD5P2bCxy29byOibmMewOkEA/640?wx_fmt=png)

## 抖动

> 如果`分配`给进程的`存储数量`小于进程所需要的`最小值`，进程的运行将会`很频繁`地产生`缺页中断`，这种`频繁非常高`的页面置换现象称为**`抖动`**。`页面内存`与`外存`之前`频繁调度`，以至于`调度页面所需时间`比`进程实际运行时间`还多，此时`系统效率`极具`下降`，导致`系统崩溃`。这种现象称为 `颠簸`或`抖动`。

## 段式存储

> 按`用户作业`中的`自然段`来划分逻辑空间，然后`调入内存`，段的长度可以不一样
>
> 段表要记录: `断号`，`段长`，`基址`
>
> 优点： `多道程序`共享内存，各段程序修改互不影响
>
> 缺点：`内存利用率低`，`内存碎片`浪费`大`

![段页式](https://mmbiz.qpic.cn/mmbiz_jpg/ORog4TEnkbsEcibd47DQia7ibYjMicEvylA9oiaELcaUhMsb3ficiaL5amFNcrjcS8In9CvZIiaCibNjNHwKk9EaicZFibKow/640?wx_fmt=jpeg)

## 段页式存储

> `段式`和`页式`的`综合体`，`先分段`，`再分页`。`1个`程序有`若干个段`，`每个段`中可以`有若干页`，`每个页`的`大小相同`，但`每个段`的`大小不同`。

![段页式存储](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbuIQJperDJ3XAtWsba2Pp2qS2xJaE5icl237I0WuicIojibWPb47Ue99g8z87gXPQUZ06JK18PLG6Gjg/640?wx_fmt=png)

> * 优点： `空间浪费小`，存储`共享容易`，`存储保护容易`，`能动态连接`
> * 缺点：由于`管理软件的增加`，`复杂性`和`开销`也随之增加，需要的`硬件`以及`占用的内容`也有`所增加`，使得`执行速度`大大`下降`。

## 虚拟存储管理

> * `时间`局限性：程序中某条指令一旦执行，`不久的将来`可能会被再次执行
> * `空间`局限性 ： 一旦程序`访问`了`某个存储单元`，不久的将来，其`附近的存储单元`也可能被访问。

## 页面置换算法

> * `最优`(Optimal ,`OPT`)算法
> * `随机算法`( `Rand` )
> * `先进先出` ( `FIFO `)算法：可能会产生`抖动`，
> * 最近最少使用`LRU`算法：不会`抖动`，`LRU`的理论依据是`局部性原理`

## 磁盘管理

> `存取时间 = 寻道时间+等待时间`，`寻道时间`是指`磁头移动`到`磁道所需`的时间；`等待时间`为`等待读写的删去`转到`磁头下方所用的时间`。

![磁盘管理](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbuIQJperDJ3XAtWsba2Pp2qKgMjb4Qt6ibEg2et0wtd4oeWMxOsA4Eu3iaXkdD7MXJzmhta76fiaAjUw/640?wx_fmt=png)

![垂直盘快](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbsEcibd47DQia7ibYjMicEvylA9yQCMlV59OJgxSxhvDPQAgqYibPypxJtMP15Ea9C03KiaibUEdYEjibX4YQ/640?wx_fmt=png)

> 读取磁盘数据的时间包含三个部分 ：
>
> * `找磁道的时间`
> * 找块(扇区)的时间，即`旋转延迟的时间`
> * `传输时间`
>
> **磁盘读取时间 = 寻道时间 + 旋转延迟时间 + 传输时间**

## 磁盘调度算法

* `先来先`服务（`FCFS`) ： 谁先申请，响应谁
* `最短寻道`时间优先(`SSTF`) ： 当前情况，剩下的申请中谁离磁道数近就先相应谁
* `扫描`算法（`SCAN`) ：(电梯算法) 从内到外，从外到内双向扫描中间所遇到的所有申请，来进行处理
* `循环`扫描（`CSCAN`算法) : 从内到外 或者 从外到内 单向扫描中间所遇到的所有申请，来进行处理。

> `读取磁盘数据`实现应包含的`三个部分`
>
> * `找磁道`的时间
> * 找`块(扇区)`的时间，即`旋转延迟`时间
> * `传输时间`

# 作业管理

![作业管理](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbuIQJperDJ3XAtWsba2Pp2qxBickBUia9XDGiaVbqHbkvOpGE8x4l1DXYDE2nfA0DFTnpFIniaVtECsIw/640?wx_fmt=png)

## 作业调度算法

* `先来先服务`
* `时间片轮转法`
* `短作业优先法`
* `最高优先权优先法`
* `高响应比优先法`：`作业等待时间/执行时间`

# 文件管理

> 文件管理的**目的**： 负责管理**外存储器上**的信息，是用户可以`按名`高效，快捷和方便地存储信息。

## 索引文件结构(文件的物理结构)

### 连续结构

> 将**逻辑上**连续的`文件信息`依次连续`存放在`连续编号的物理块上(顺序表)，只要指导文件的`起始物理块号`和文件的`长度`就很方便进行文件的`存取`

### 链式结构(串联结构)

> 将逻辑上`连续`的`文件信息`存放在`不连续`的`物理块`上，每个物理块设有一个指针指向下个物理块(`链表`)
>
> 只知道文件的`第一个`物理块号，就可以`按链指针`查找`整个文件`

### 索引结构(重点)

> 采用`索引结构`时，将`逻辑`上`连续的文件信息`存放在`不连续的物理块`中，系统为`每个文件`建立一`张索引表`，
>
> `索引表记录了文件信息`所在的`逻辑块号`对应的`物理块号`，并将`索引表`的`起始地址`放在与`文件对应`的`文件目录项`中。

> 分为`13个`索引节点，从`0`开始 
>
> * `一级`间接索引：`256K`
> * `物理`盘快 ：` 64M`
> * `三级`间接索引： `16G`

![索引文件结构](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbsEcibd47DQia7ibYjMicEvylA97xUBuCoVP3Bu1l7Dy2xN5rbevzNQCE777nW6dy1hFZe7PJEZibwmLug/640?wx_fmt=png)

## 绝对&相对路径

> `Linux`系统的`目录结构`，
>
> 考察`相对路径`，`绝对路径`。

![树形目录结构](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbuIQJperDJ3XAtWsba2Pp2qsvIJ1OWETpAzLQSyoaeWdWMMWTibicgqv9WnytlBRaznAO3HsCMQmJdg/640?wx_fmt=png)

![操作管理](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbuIQJperDJ3XAtWsba2Pp2q4gL2k4jNsr8LmTN3mic48BUlMIKtjVp1cYCfM5NGSPic5W4c5ZMiayL9A/640?wx_fmt=png)

# 设备管理

> 设备管理技术主要包括 ：` 通道`，`DMA`，`缓冲`，`Spooling技术`。

## `数据传输控制`方式

![数据传输控制方式](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbuIQJperDJ3XAtWsba2Pp2qiaEREZ35MN5QeBBdiamYCN0Yt53cpWEUDqrGrvOAq2gn19stUr76w1TQ/640?wx_fmt=png)

## SPOOLING技术

> `SPOOLing`是关于`慢速字符设备`如何与`计算机主机`交换信息的一种技术，通常称为`假脱机技术`，`SPOOLing`技术通过`磁盘实现`
>
> Spooling技术用一类`物理设备`**模拟**另一类物理设备，使`独占`使用的设备变成`多态虚拟`设备，它也是一种速度匹配技术。
>
> Spooling系统中拥有一张作业表，用来登记进入系统的所有作业的作业名，状态和预输入表位置灯信息
>
> 每个用户作业拥有一张输入表用来登记作业的各个文件的情况，包括`设备类`，`信息长度`及`存储位置`等。

### 组成

> `Spooling`系统由`预输入程序`，`缓输出程序`，`井管理程序`以及`输入输出井`组成。

![SPOOLing技术](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbuIQJperDJ3XAtWsba2Pp2qWefjBTicqXzmoU5l2ibTkOaftr2kIAudtdpSHdcwulpSBsz4c5QpzPYg/640?wx_fmt=png)

> `输入`和`输出`并用于`存放从输入`的信息以及`作业执行`的结果，是系统在`辅助存储器`上`开辟`的`存储区域`。

### 输入井

> 输入井有4中状态：`输入`，`收容`，`执行`，`完成`
>
> * 输入：作业的信息正才能够输入设备上`预输入`
> * `收容`：作业`预输入`结束但`未被选中执行`
> * `执行状态` ： 作业已被选中运行，运行过程中，它可从`输入井`中**读取**数据信息，也可向`输出井写`信息
> * 完成状态 ： 作业已经撤离，由系统进行善后处理。

# 微内核操作系统

> 微内核操作系统把内核做的**更小**的操作系统，使系统的`可靠性`，`稳定性`和`安全性`得到提高，降低问题发生的概率，只把最核心的部分放入内核。

![微内核](https://mmbiz.qpic.cn/mmbiz_png/ORog4TEnkbsEcibd47DQia7ibYjMicEvylA92Nc1uOFCiaT7Tib6Cxu9GU0DaU1P7t7QpkjictWFW2o1TJcs5cFbt1ohw/640?wx_fmt=png)

# 人机界面

> 计算机用户界面发展经历了4个阶段：`控制面板式`用户界面，`字符用户界面`，`图形用户界面`及`新一代用户界面`。

## 图标设置准则

* 定义`准确形象`
* `表达符合`的行为习惯
* `风格表现统一`
* 使用`配色的协调`

# 参考资料

> * [PV操作](https://blog.csdn.net/tu_wer/article/details/120903321)
> * 希赛软考
> * [死锁](https://www.jianshu.com/p/105d76b69e15)
> * [存储管理](https://blog.csdn.net/m0_67601373/article/details/124648410)
> * [磁道管理](https://blog.51cto.com/u_15980166/6086560)
> * [文件管理](https://blog.csdn.net/soaipipiop/article/details/127375964)
> * [文件与作业管理人机界面](https://blog.csdn.net/soaipipiop/article/details/127326103)