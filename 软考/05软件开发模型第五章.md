# 软件开发模型

## 瀑布模型

>  分为三个阶段：`定义阶段`，`开发阶段`，`维护阶段`。按照`固定顺序`而连接的`若干阶段工作`。
>
>  `需求` ->` 设计 `- - > `编码 ` – > `测试 `—- > `维护`
>
>  瀑布模型为`线性开发`，必须`上一个阶段完成之后`且`审核通过`才能进入`下一个阶段`
>
>  * 每个阶段都会产生`大量文档`
>  * `开发周期长`，`项目时间长`
>  * `适应需求变`化`能力差`
>  * 由于公司对`成本`的`控制`相对`成本也较差`
>  * 强调`开发`的`先后顺序`
>
>  优点：
>
>  * 各阶段`划分清晰`
>  * 强调`计划`与`需求分析`
>  * 适合`需求稳定产品开发`
>
>  缺点:
>
>  * `单一流程`，不可逆
>
>  * 风险`显露晚`，纠正机会少
>
>  * 测试只是一个阶段，缺乏全过程测试思想
>
>  瀑布模型一般都将开发过程划分为 ： `分析`，`设计`，`编码`，和`测试等阶段`。

![瀑布模型](./assets/image-20231003124307801.png)

> `适用场景`
>
> * `需求明`确，稳定的场景
> * `很少`需要`变更`的项目
> * 在开发时间内`需求不变化/很少变化`
> * 分析`设计人员`对此`领域十分熟悉`
> * `低风险项目`
> * 用户`使用环境稳定`(如`系统软件`，`工具软件`)

## V模型

> 通过`开发`和`测试同时进行`的方式来缩短开发周期，`提高开发效率`。
>
> 特点：
>
> * `V模型`体现了`开发`和`测试`同等重要的思想
> * 把`测试分成多个阶段`，非常重视测试
> * 典型的`测试驱动模型`：软件开发的过程是`由测试来驱动的`
> * 非常`明确地标明了`测试过程中`存在的不同等级`
> * 清楚地描述了这些`测试阶段`和`开发各阶段`的`对应关系`
>
> 优点：
>
> * 此模式`更注重设计与测试`，开发出来的产品`质量有保证`。
> * 相对于瀑布模型，V模型测试可以尽早的进入到开发阶段
>
> 缺点:
>
> * 虽然测试尽早的进入到开发阶段，但是真正进行软件测试是在编码之后，忽视了测试对需求分析，系统设计的验证，时间效率上大大折扣。
>

![V模型](./assets/05V%E6%A8%A1%E5%9E%8B.png)

> 适用场景：
>
> ​	需求明确，需求变更不频繁的场景。使用V模型一般为大型企业开发的大型软件，如银行外包，开发银行相关软件，开发时间一年半载，流程严格，质量要求也很高。



## 喷泉模型

> 以用户需求为动力，以对象为驱动模型
>
> 特点：
>
> * 面向对象
> * 同步开展：开发过程所固有的递归和开发各阶段之间无`间隙`的特征，各阶段没有明显的界限，开发人员可以同步进行开发。提高了项目开发效率，节省开发时间。
>
> 缺点：
>
> * 各个开发阶段是重叠的，需要大量的开发人员，因此不利于项目的管理
> * 严格管理文档，审核难度加大，面对可能随时加入各种信息，需求与资料的情况。

> 也称为 `面向对象的生存期模型`，OO模型。
>
> 喷泉模型生存期的各个阶段可以`相互重叠`和`多次反复`，而且在项目的整个生存期还可以`嵌入生存期`，

![喷泉模型](./assets/05%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B.png)







## 原型化模型

> 适合于`需求不明确`的场景，可以帮助`用户明确需求`。
>
> 第一步：创建一个`快速原型`，能够满足项目干系人与未来的用户可以与原型进行交互，再通过与相关干系人进行充分的讨论与分析，最终弄清楚当前系统的需求，进行充分了解之后，在原型的基础上开发出用户满意的产品。



> 缺点：
>
> * 产品需求在开始不清楚会给总体设计带来困难及削弱产品设计的完整性，影响产品性能的优化及产品的可维护性
> * 若缺乏严格的过程管理，此生命周期模型很可能退化为 `试 - 错 - 改` 模式
> * 不加控制用户接触未测试功能，对开发人员产生负面影响。

> 分类：
>
> * 抛弃型原型(快速原型) ：该类原型只用于获取需求，得到需求后抛弃原型
> * 进化型原型：将原型逐步烟花成最终系统

## 演化模型Evolutionary Model

> 主要针对事先`不能完整定义需求`的软件开发。用户可以给出`待开发系统的核心`需求，并且当看到核心需求实现后，能够`有效地提出反`馈，以`支持`系统的`最终设计与实现`。
>
> 在开发模式上采取`分批循环开发`的方法，每循环开发一部分的功能，它们成为这个产品的原型的`新增功能`。于是，设计就`不断地演化出新的系统`。
>
> 特点:
>
> * 一经开发就进入测试以便验证是否满足产品需求
> * 帮助引导出高质量的产品要求
> * 开发中的经验教训能反馈应用于本产品的下一个循环过程，提高质量与效率
> * 新一批功能开发测试后，立即参与验证，以便提供非常有价值的反馈



## 螺旋模型(瀑布 + 原型 = 螺旋)

> 一般在软件开发阶段需求不是很明确，采用渐进式开发模式。
>
> 是`渐进式` 的，强调的是`风险`，每个环里面都有风险分析这一阶段，每个环的工作都比前一环更多，是为了减少项目风险。
>
> 四个步骤：
>
> * 制定计划 ： 确定软件目标，选定实施标准，弄清楚项目开发的限制条件
> * 风险分析 ： 分析所选方案，识别和消除风险
> * 实施工程 ： 实施软件开发
> * 客户评估 ：评价开发工作，提出修改意见
>
> 说明：
>
> * 强调风险分析
> * 风险驱动，风险分析人员需要有经验且经过充分训练
> * 兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控
> * 
>
> 适合 ： 复杂度高，风险大，规模庞大
>
> 优点：
>
> * 强调项目的`风险`，即强调`严格的全过程风险管理`
> * 强调`各开发阶段的质量`
> * 提供`机会检讨项目`是否有价值`继续`下去
>
> 缺点：
>
> * 引入非常严格的风险识别，风险分析，风险控制，对风险管理的技术水平有更高的要求
> * 风险分析需要时间，添加成本 ，因而会造成项目进度缓慢。







![螺旋模型](https://img-blog.csdnimg.cn/20200312083818708.png)

> 应用场景：
>
> * 适用于庞大而复杂的，高风险的系统
> * 大型复杂
> * 更适合大型的昂贵的系统级软件应用
> * 系统庞大，风险高。需求不太明确。
>
> 使用步骤：
>
> * 决定目标，替代方案和约束
> * 识别和解决项目风险
> * 评估技术方案和替代解决方案
> * 开发本次迭代的交付物和验证迭代产出的正确性
> * 计划下一次迭代
> * 提交下一次步骤方案

## 统一过程

> `用例驱动`为导向(注重`功能的完善`)，以`软件架构`为核心(严格的结构过程)，经过`多次迭代`(不像大瀑布模型一样一通到底)增量(可不断扩展的功能需求)的软件过程框架，由`UML方法`及其`工具支持`。

![统一过程](./assets/image-20230923095011700.png)

![统一过程模型演示](https://img-blog.csdnimg.cn/img_convert/8740963f3cf5e9629bdde466912a7717.png)

> 每个阶段都是一次迭代的过程，都要经历每个核心工作流程 –  –  `建模`，`需求捕获`，`分析`和`设计`，`实现 `…. 这些`典型`的`软件开发`流程。其中又根据`每个阶段`的`侧重点`各有`详略` ，根据`上图`可以`清晰`的开到`整个软件的`开发使用`统一过程建模`的开发流程。

### 模型4个阶段

> * 初始化阶段：建立业务模型和大概的需求分析
> * 细化阶段：完善模型和需求分析，做出分析设计以及相应的支持关键架构和服务代码，再反过来贩毒案分析合理性
> * 构建阶段：主要完成代码实现与相关配置
> * 移交(转换)阶段：将其部署到实际使用环境，做好维护准备，应对可能得更新升级问题。

### 6种实践方法

> * 迭代式开发
> * 持续不断地验证和维护软件质量
> * 管理需求(明确软件设计需求，以此为目标，阶段性朝目标前进)
> * 控制软件变更(在迭代过程中，明确和严格控制软件的更新方向)
> * 可视化建模(使用UML建立模型)
> * 基于构件的结构体系



## 敏捷开发模型

> 以`人`为`核心`，`快速迭代`，`循序渐进`的开发方式。强调以人为本，专注于交付对客户有价值的软件，是一个用于开发和维持复杂产品的结构，把一个大项分成对个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。
>
> 特点：
>
> * `短周期开发`
> * `增量`开发
> * 由`程序员`和`测试人员编写`的`自动化测试`来监控开发进度
> * 通过`口头沟通`，`测试`和`源代码`来交流系统的`结构`和`意图`
> * `编写代码`之前先写`测试代码`，也叫做`测试先行`。
>
> 优点：
>
> * 注重市场`快速反应能力`，具体`应对能`力，客户前期满意度高
>
> 缺点：
>
> * 忽略对文档的重要性，若人员流动性较大，给维护带来不少难度。
> * 团队组件困难，对每个员工要求很高
> * `测试人员`完全`掌握各种脚本语言`，`单元测试`。

![敏捷开发](https://img-blog.csdnimg.cn/20200811143935546.png)

![基本原则](./assets/image-20230923095131870.png)

* `XP`( `Extreme PProgramming` ,极限编程) ：适用于对`费用控制严格`的公司中使用，
* `Cockburn` 水晶系列方法：用`最少纪律约束`而仍能够成功的方法，从而在产出`效率与易于运`作上达到一种平衡。
* `开源式源码`：程序开发在`地域上分布很广`。

> 使用场景：
>
> * 小项目，小步快跑
> * 小公司用的最多的开发模型

![敏捷开发与迭代开发](./assets/05%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%BC%80%E5%8F%91.png)

# 软件开发方法

> * 用户至上
> * 严格区分工作阶段，每阶段有任务和结果
> * 强调系统开发过程的整体性和全局性
> * 系统开发过程工程化，文档资料标准化
> * 自顶向下，逐步分解(求精)

# 面向对象方法

* 更好的复用性
* 关键在于建立一个全面，合理，统一的模型
* 分析，设计，实现三个阶段，界限不明确
* 面向服务的方法

## 需求的过程

* 问题识别
* 分析与综合
* 编址需求分析文档
* 需求分析与评审

## 需求的分类

* 功能需求
* 非功能需求
* 设计约束

## 应用的工具

* 数据流图DFD
* 数据字典DD
* 判定表
* 判定树



#  软件设计

![高内聚低耦合](./assets/image-20230923100350285.png)

## 高内聚低耦合顺序(考点)

![由高到底](./assets/image-20230923100440279.png)



# 软件测试与维护



![软件测试](./assets/image-20230923100625034.png)

## 等价类划分

> 确定无效与有效等价类，设计用例尽可能多的覆盖有效类，设计用例只覆盖一个无效类。

## 边界值分析

> 处理边界情况时最容易出错，选取的测试数据应该恰好等于，稍小于或稍大于边界值。

## V模型测试

> * 回归测试
> * 负载测试
> * 压力测试

![V模型测试](./assets/image-20230923101340260.png)

## McCabe环路复杂度(重点)

>  环路复杂度用来定量度量程序的逻辑复杂度。
>
> 在程序控制流程图中，节点是程序中代码的最小单元，边代表节点间的程序流。一个有e条边和n个节点的流程图F,可以用下述三种方法中的任何一种来计算环形复杂度。
>
> * `流图`中的`区域`数`等于`环形`复杂度`
> * 流图`G`的`环形复杂度`V(G) = E - N + 2， 其中，E是流图中 `边的条数`，`N是结点数`。
> * 流图G的环形复杂度V(G) = P + 1，其中，P是流图中判定节点的数目。

## 软件维护

> * `适应性`维护：指使应用软件适应信息`技术变化`和`管理需求`变化而进行的修改。企业的外部市场环境和管理需求的不断变化也使得各级管理人员不断提出信息的信息需求
> * `完善性`维护:`扩充功能`和`改善性能`而进行的修改，对`已有软件系统添加`，在系统分析和设计阶段中没有规定的功能与性能特性。

> 可维护性因素：主要`以文档`为主。

![软件维护](./assets/image-20230923102758434.png)

# 软件工程

## 文档管理

![软件文档](./assets/image-20230923103007358.png)

## 软件质量保证

![软件质量保证](./assets/image-20231003133933878.png)



## 软件过程改进`CMMI`

![软件改进过程](./assets/image-20230923103129239.png)

# 项目管理

![项目管理](./assets/image-20230923103943433.png)

> `风险曝光度`( `Risk Exposure` ) : 计算方法，`风险出现的概率`乘以`风险可能造成的损失`。 最后根据`风险曝光度`来计算出可能给`公司`造成的`损失`。

![九大知识领域](./assets/image-20230923103209489.png)

# 时间管理

## 关键路径法

> 关键路径法沿着`项目进度`网络路线进行`正向`与`反向分析`，从而计算出所有计划活动理论上的`最早时间`与`完成日期`，`最迟开始`与`完成日期`，`不考虑`任何`资源限制`。

## 总时差(松弛时间)

> 在不耽误总工期的前提下，该活动的机动时间。活动的总时差等于该活动最迟完成时间与最早完成时间之差，或该活动最迟开始时间与最早开始时间之差。

![总时差](./assets/image-20230923103827671.png)

## 活动排序

![活动排序](./assets/image-20230923103909250.png)





# 参考资料

* [软件开发常见模型汇总](https://blog.csdn.net/qq_41854911/article/details/131367786)
* [螺旋模型](https://blog.csdn.net/qq_46501800/article/details/104981195)
* [统一过程模型](https://blog.csdn.net/caqjeryy/article/details/124283831)
* [软件开发模型](https://blog.csdn.net/wstever/article/details/129578073)