# 算法大题

> * 填空
> * 看懂他人代码
> * 得  3~ 9 分
> * 此程序属于哪一种方法 如下四选一
> * 求时间复杂度‘
> * 第一题：填初始化 一般

# 分治法

## 递归

> * 分而治之
> * `规模大`的时候：将`大问题`分成比`较小`**相同**的`子问题`，这些子问题`相互独立`且与`原问题形式相同`，`递归解决`这些问题
> * 递归：在运行过程中调用自己。

### 什么时候考虑递归

> * 问题与子问题有递推关系
> * 具有递归性质的数据结构，比如:俩表，树，图
> * 反向性问题 ： 取反

## 二分查找法



# 回溯法

> * 回溯 选优搜索法，按选优向前搜索，以达到目标
> * 当搜索发现并不优或达不到目标，就退回重新选择

# 贪心法

> * 做出当前来说最好的选择，即局部最优解(但整体并不一定最优)
> * 不必寻找最优切穷尽所有可能，耗费时间少，可以快速找到满意解

# 动态规划法(求最优)

> * 把大问题分成很多步骤
> * 对于每一步，列出所有可能解，根据判断区能得到最优解的局部解
> * 以每一步都是最优解，来保证全局最优解

# 经典问题

> * 斐波那契数列
> * 归并排序
> * 快速排序
> * 矩阵乘法
> * 二分搜索
> * 大整数乘法
> * 汉诺塔

> * 背包问题
> * LCS最长公共子序列

> * N皇后问题
> * 迷宫
> * 背包问题

> * 背包问题(如装箱)
> * 多机调度
> * 找零钱问题



# 时间复杂度

![时间复杂度](./assets/image-20231004170556113.png)

* 0(1)

> 整个程序都没有循环语句，或复杂函数的调用

* 0(n)，0(n^2)

> for的n循环，双层n的for循环

* 0(log2n)

> 二分查找

* 0(n*log2n)

> 典型代表：堆排序，每次重建堆的时间复杂度是**log2n**,`n`个元素基本上就是**nlog2n**

